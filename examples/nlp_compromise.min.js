(function(f) {
    if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f();
    } else if (typeof define === "function" && define.amd) {
        define([], f);
    } else {
        var g;
        if (typeof window !== "undefined") {
            g = window;
        } else if (typeof global !== "undefined") {
            g = global;
        } else if (typeof self !== "undefined") {
            g = self;
        } else {
            g = this;
        }
        g.nlp_compromise = f();
    }
})(function() {
    var define, module, exports;
    return function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof require == "function" && require;
                    if (!u && a) return a(o, !0);
                    if (i) return i(o, !0);
                    var f = new Error("Cannot find module '" + o + "'");
                    throw f.code = "MODULE_NOT_FOUND", f;
                }
                var l = n[o] = {
                    exports: {}
                };
                t[o][0].call(l.exports, function(e) {
                    var n = t[o][1][e];
                    return s(n ? n : e);
                }, l, l.exports, e, t, n, r);
            }
            return n[o].exports;
        }
        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++) s(r[o]);
        return s;
    }({
        1: [ function(require, module, exports) {
            "use strict";
            var honourifics = require("./honourifics");
            var main = [ "arc", "al", "exp", "rd", "st", "dist", "mt", "fy", "pd", "pl", "plz", "tce", "llb", "md", "bl", "ma", "ba", "lit", "ex", "eg", "ie", "circa", "ca", "cca", "vs", "etc", "esp", "ft", "bc", "ad" ];
            main = main.concat(honourifics);
            var orgs = [ "dept", "univ", "assn", "bros", "inc", "ltd", "co", "corp", "yahoo", "joomla", "jeopardy" ];
            main = main.concat(orgs);
            var places = [ "ariz", "cal", "calif", "col", "colo", "conn", "fla", "fl", "ga", "ida", "ia", "kan", "kans", "md", "minn", "neb", "nebr", "okla", "penna", "penn", "pa", "dak", "tenn", "tex", "ut", "vt", "va", "wis", "wisc", "wy", "wyo", "usafa", "alta", "ont", "que", "sask", "ave", "blvd", "cl", "ct", "cres", "hwy" ];
            main = main.concat(places);
            var dates = [ "jan", "feb", "mar", "apr", "jun", "jul", "aug", "sep", "oct", "nov", "dec", "sept", "sep" ];
            main = main.concat(dates);
            module.exports = {
                abbreviations: main,
                dates: dates,
                orgs: orgs,
                places: places
            };
        }, {
            "./honourifics": 9
        } ],
        2: [ function(require, module, exports) {
            "use strict";
            var fns = require("../fns");
            var compressed = {
                erate: "degen,delib,desp,lit,mod",
                icial: "artif,benef,off,superf",
                ntial: "esse,influe,pote,substa",
                teful: "gra,ha,tas,was",
                stant: "con,di,in,resi",
                going: "easy,fore,on,out",
                hing: "astonis,das,far-reac,refres,scat,screec,self-loat,soot",
                eful: "car,grac,peac,sham,us,veng",
                ming: "alar,cal,glea,unassu,unbeco,upco",
                cial: "commer,cru,finan,ra,so,spe",
                tful: "deligh,doub,fre,righ,though,wis",
                ight: "overn,overwe,r,sl,upt",
                ated: "antiqu,intoxic,sophistic,unregul,unrel",
                rant: "aber,exube,flag,igno,vib",
                uent: "congr,fl,freq,subseq",
                rate: "accu,elabo,i,sepa",
                ific: "horr,scient,spec,terr",
                rary: "arbit,contempo,cont,tempo",
                ntic: "authe,fra,giga,roma",
                wing: "harro,kno,left-,right-",
                nant: "domi,malig,preg,reso",
                nent: "emi,immi,perma,promi",
                iant: "brill,def,g,luxur",
                ging: "dama,encoura,han,lon",
                iate: "appropr,immed,inappropr,intermed",
                rect: "cor,e,incor,indi",
                zing: "agoni,ama,appeti,free",
                ant: "abund,arrog,eleg,extravag,exult,hesit,irrelev,miscre,nonchal,obeis,observ,pl,pleas,redund,relev,reluct,signific,vac,verd",
                ing: "absorb,car,coo,liv,lov,ly,menac,perplex,shock,stand,surpris,tell,unappeal,unconvinc,unend,unsuspect,vex,want",
                ate: "adequ,delic,fortun,inadequ,inn,intim,legitim,priv,sed,ultim",
                ted: "expec,impor,limi,spiri,talen,tes,unexpec,unpreceden",
                ish: "dan,fool,hell,lout,self,snobb,squeam,styl",
                ary: "dre,legend,necess,prim,sc,second,w,we",
                ite: "el,favor,fin,oppos,pet,pol,recond,tr",
                ely: "hom,lik,liv,lon,lov,tim,unlik",
                ure: "fut,insec,miniat,obsc,premat,sec,s",
                tly: "cos,ghas,ghos,nigh,sain,sprigh,unsigh",
                dly: "cowar,cud,frien,frien,kin,ma",
                ble: "a,dou,hum,nim,no,proba",
                rly: "bu,disorde,elde,hou,neighbo,yea",
                ine: "div,femin,genu,mascul,prist,rout",
                ute: "absol,ac,c,m,resol",
                ped: "cram,pum,stereoty,stri,war",
                sed: "clo,disea,distres,unsupervi,u",
                lly: "chi,hi,jo,si,sme",
                per: "dap,impro,pro,su,up",
                ile: "fert,host,juven,mob,volat",
                led: "detai,disgrunt,fab,paralle,troub",
                ern: "east,north,south,st,west",
                ast: "e,l,p,steadf",
                ent: "abs,appar,b,pres",
                ged: "dama,deran,jag,rag",
                ded: "crow,guar,retar,undeci",
                est: "b,dishon,hon,quick",
                ial: "colon,impart,init,part",
                ter: "bet,lat,ou,ut",
                ond: "bey,bl,sec,vagab",
                ady: "he,re,sh,ste",
                eal: "ether,id,r,surr",
                ard: "abo,awkw,stand,straightforw",
                ior: "jun,pr,sen,super",
                ale: "fem,m,upsc,wholes",
                ed: "advanc,belov,craz,determin,hallow,hook,inbr,justifi,nak,nuanc,sacr,subdu,unauthoriz,unrecogniz,wick",
                ly: "dai,deep,earth,gris,heaven,low,meas,melancho,month,oi,on,prick,seem,s,ug,unru,week,wi,woman",
                al: "actu,coloss,glob,illeg,leg,leth,liter,loy,ov,riv,roy,univers,usu",
                dy: "baw,bloo,clou,gau,gid,han,mol,moo,stur,ti,tren,unti,unwiel",
                se: "adver,den,diver,fal,immen,inten,obe,perver,preci,profu",
                er: "clev,form,inn,oth,ov,she,slend,somb,togeth,und",
                id: "afra,hum,langu,plac,rab,sord,splend,stup,torp",
                re: "awa,bizar,di,enti,macab,me,seve,since,spa",
                en: "barr,brok,crav,op,sudd,unev,unwritt,wood",
                ic: "alcohol,didact,gener,hispan,organ,publ,symbol",
                ny: "ma,pho,pu,shi,skin,ti,za",
                st: "again,mo,populi,raci,robu,uttermo",
                ne: "do,go,insa,obsce,picayu,sere",
                nd: "behi,bla,bli,profou,undergrou,wou",
                le: "midd,multip,sing,so,subt,who",
                pt: "abru,ade,a,bankru,corru,nondescri",
                ty: "faul,hef,lof,mea,sal,uppi",
                sy: "bu,chee,lou,no,ro",
                ct: "abstra,exa,imperfe,inta,perfe",
                "in": "certa,highfalut,ma,tw,va",
                et: "discre,secr,sovi,ups,viol",
                me: "part-ti,pri,sa,supre,welco",
                cy: "boun,fan,i,jui,spi",
                ry: "fur,sor,tawd,wi,w",
                te: "comple,concre,obsole,remo",
                ld: "ba,bo,go,mi",
                an: "deadp,republic,t,urb",
                ll: "a,i,overa,sti",
                ay: "everyd,g,gr,ok",
                or: "indo,maj,min,outdo",
                my: "foa,gloo,roo,sli",
                ck: "ba,qua,si,sli",
                rt: "cove,expe,hu,ove",
                ul: "fo,gainf,helpf,painf"
            };
            var arr = [ "ablaze", "above", "adult", "ahead", "aloof", "arab", "asleep", "average", "awake", "backwards", "bad", "blank", "bogus", "bottom", "brisk", "cagey", "chief", "civil", "common", "complex", "cozy", "crisp", "deaf", "devout", "difficult", "downtown", "due", "dumb", "eerie", "evil", "excess", "extra", "fake", "far", "faux", "fierce ", "fit", "foreign", "fun", "good", "goofy", "gratis", "grey", "groovy", "gross", "half", "huge", "humdrum", "inside", "kaput", "left", "less", "level", "lewd", "magenta", "makeshift", "mammoth", "medium", "moot", "naive", "nearby", "next", "nonstop", "north", "offbeat", "ok", "outside", "overwrought", "premium", "pricey", "pro", "quaint", "random", "rear", "rebel", "ritzy", "rough", "savvy", "sexy", "shut", "shy", "sleek", "smug", "solemn", "south", "stark", "superb", "taboo", "teenage", "top", "tranquil", "ultra", "understood", "unfair", "unknown", "upbeat", "upstairs", "vanilla", "various", "widespread", "woozy", "wrong", "final", "true", "modern", "notable" ];
            module.exports = fns.expand_suffixes(arr, compressed);
        }, {
            "../fns": 23
        } ],
        3: [ function(require, module, exports) {
            "use strict";
            module.exports = [ "absurd", "aggressive", "alert", "alive", "awesome", "beautiful", "big", "bitter", "black", "blue", "bored", "boring", "brash", "brave", "brief", "bright", "broad", "brown", "calm", "charming", "cheap", "clean", "cold", "cool", "cruel", "cute", "damp", "deep", "dear", "dead", "dark", "dirty", "drunk", "dull", "eager", "efficient", "even", "faint", "fair", "fanc", "fast", "fat", "feeble", "few", "fierce", "fine", "flat", "forgetful", "frail", "full", "gentle", "glib", "great", "green", "gruesome", "handsome", "hard", "harsh", "high", "hollow", "hot", "impolite", "innocent", "keen", "kind", "lame", "lean", "light", "little", "loose", "long", "loud", "low", "lush", "macho", "mean", "meek", "mellow", "mundane", "near", "neat", "new", "nice", "normal", "odd", "old", "pale", "pink", "plain", "poor", "proud", "purple", "quick", "rare", "rapid", "red", "rich", "ripe", "rotten", "round", "rude", "sad", "safe", "scarce", "scared", "shallow", "sharp", "short", "shrill", "simple", "slim", "slow", "small", "smart", "smooth", "soft", "sore", "sour", "square", "stale", "steep", "stiff", "straight", "strange", "strong", "sweet", "swift", "tall", "tame", "tart", "tender", "tense", "thick", "thin", "tight", "tough", "vague", "vast", "vulgar", "warm", "weak", "wet", "white", "wide", "wild", "wise", "young", "yellow", "easy", "narrow", "late", "early", "soon", "close", "empty", "dry", "windy", "noisy", "thirsty", "hungry", "fresh", "quiet", "clear", "heavy", "happy", "funny", "lucky", "pretty", "important", "interesting", "attractive", "dangerous", "intellegent", "pure", "orange", "large", "firm", "grand", "formal", "raw", "weird", "glad", "mad", "strict", "tired", "solid", "extreme", "mature", "true", "free", "curly", "angry" ].reduce(function(h, s) {
                h[s] = "Adjective";
                return h;
            }, {});
        }, {} ],
        4: [ function(require, module, exports) {
            "use strict";
            module.exports = [ "usd", "cad", "aud", "gbp", "krw", "inr", "hkd", "dkk", "cny", "xaf", "xof", "eur", "jpy", "denar", "dobra", "forint", "kwanza", "kyat", "lempira", "pound sterling", "riel", "yen", "zloty", "dollar", "cent", "penny", "dime", "dinar", "euro", "lira", "pound", "pence", "peso", "sterling", "rand", "rouble", "shekel", "sheqel", "yuan", "franc", "rupee", "shilling", "krona", "dirham", "bitcoin", "€", "$", "¥", "£", "лв", "₡", "kn", "kr", "¢", "Ft", "Rp", "﷼", "₭", "ден", "₨", "zł", "lei", "руб", "฿" ];
        }, {} ],
        5: [ function(require, module, exports) {
            "use strict";
            var months = [ "january", "february", "april", "june", "july", "august", "september", "october", "november", "december", "jan", "feb", "mar", "apr", "jun", "jul", "aug", "sep", "oct", "nov", "dec", "sept", "sep" ];
            var days = [ "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday", "mon", "tues", "wed", "thurs", "fri", "sat", "sun" ];
            for (var i = 0; i <= 6; i++) {
                days.push(days[i] + "s");
            }
            var durations = [ "millisecond", "second", "minute", "hour", "morning", "afternoon", "evening", "night", "day", "week", "month", "year", "decade" ];
            var len = durations.length;
            for (var i = 0; i < len; i++) {
                durations.push(durations[i] + "s");
            }
            durations.push("century");
            durations.push("centuries");
            var relative = [ "yesterday", "today", "tomorrow", "week", "weekend", "tonight" ];
            module.exports = {
                days: days,
                months: months,
                durations: durations,
                relative: relative
            };
        }, {} ],
        6: [ function(require, module, exports) {
            "use strict";
            module.exports = [ "afghan", "albanian", "algerian", "angolan", "argentine", "armenian", "australian", "aussie", "austrian", "bangladeshi", "belarusian", "belgian", "bolivian", "bosnian", "brazilian", "bulgarian", "cambodian", "cameroonian", "canadian", "chadian", "chilean", "chinese", "colombian", "congolese", "croatian", "cuban", "czech", "dominican", "danish", "egyptian", "british", "estonian", "ethiopian", "ecuadorian", "finnish", "french", "gambian", "georgian", "german", "greek", "ghanaian", "guatemalan", "haitian", "hungarian", "honduran", "icelandic", "indian", "indonesian", "iranian", "iraqi", "irish", "israeli", "italian", "ivorian", "jamaican", "japanese", "jordanian", "kazakh", "kenyan", "korean", "kuwaiti", "lao", "latvian", "lebanese", "liberian", "libyan", "lithuanian", "namibian", "malagasy", "macedonian", "malaysian", "mexican", "mongolian", "moroccan", "dutch", "nicaraguan", "nigerian", "nigerien", "norwegian", "omani", "panamanian", "paraguayan", "pakistani", "palestinian", "peruvian", "philippine", "filipino", "polish", "portuguese", "qatari", "romanian", "russian", "rwandan", "samoan", "saudi", "scottish", "senegalese", "serbian", "singaporean", "slovak", "somalian", "sudanese", "swedish", "swiss", "syrian", "taiwanese", "trinidadian", "thai", "tunisian", "turkmen", "ugandan", "ukrainian", "american", "hindi", "spanish", "venezuelan", "vietnamese", "welsh", "zambian", "zimbabwean", "english", "african", "european", "asian", "californian" ];
        }, {} ],
        7: [ function(require, module, exports) {
            "use strict";
            var male = require("./names/male");
            var female = require("./names/female");
            var names = {};
            var ambiguous = [ "casey", "jamie", "lee", "jaime", "jessie", "morgan", "rene", "robin", "devon", "kerry", "alexis", "guadalupe", "blair", "kasey", "jean", "marion", "aubrey", "shelby", "jan", "shea", "jade", "kenyatta", "kelsey", "shay", "lashawn", "trinity", "regan", "jammie", "cassidy", "cheyenne", "reagan", "shiloh", "marlo", "andra", "devan", "rosario", "lee" ];
            for (var i = 0; i < male.length; i++) {
                names[male[i]] = "m";
            }
            for (var i = 0; i < female.length; i++) {
                names[female[i]] = "f";
            }
            for (var i = 0; i < ambiguous.length; i += 1) {
                names[ambiguous[i]] = "a";
            }
            module.exports = names;
        }, {
            "./names/female": 14,
            "./names/male": 15
        } ],
        8: [ function(require, module, exports) {
            "use strict";
            var fns = require("../fns");
            var annual = {
                "new years eve": "december 31",
                "new years": "january 1",
                "new years day": "january 1",
                thanksgiving: "fourth thursday in november",
                "christmas eve": "december 24",
                christmas: "december 25",
                "christmas day": "december 25",
                "saint patricks day": "march 17",
                "st patricks day": "march 17",
                "april fools": "april 1",
                halloween: "october 31",
                valentines: "february 14",
                "valentines day": "february 14",
                "martin luther king": "third monday in january",
                "inauguration day": "january 20",
                "washingtons birthday": "third monday in february",
                "presidents day": "third monday in february",
                "memorial day": "last monday in may",
                "labor day": "first monday in september",
                "columbus day": "second monday in october",
                "veterans day": "november 11",
                "labour day": "first monday in september",
                "commonwealth day": "second monday in march",
                "st andrews day": "november 30",
                "saint andrews day": "november 30",
                "may day": "may 1",
                "russia day": "june 12",
                "australia day": "january 26",
                "boxing day": "december 26",
                "queens birthday": "2nd monday in june",
                "canada day": "july 1",
                "victoria day": "may 24",
                "canadian thanksgiving": "second monday in october",
                "rememberance day": "november 11",
                "august civic holiday": "first monday in august",
                "natal day": "first monday in august",
                "all saints day": "november 1",
                "armistice day": "november 11",
                "bastille day": "july 14",
                "st stephens day": "december 26",
                "saint stephens day": "december 26"
            };
            var astronomical = {
                2015: {
                    "chinese new year": "february 19",
                    easter: "april 5",
                    "easter sunday": "april 5",
                    "easter monday": "april 6",
                    "good friday": "april 3",
                    "ascension day": "may 14",
                    eid: "july 17",
                    "eid al-fitr": "july 17",
                    "eid al-adha": "september 24",
                    ramadan: "june 6",
                    ashura: "23 october",
                    diwali: "11 november"
                },
                2016: {
                    "chinese new year": "february 8",
                    easter: "march 27",
                    "easter sunday": "march 27",
                    "easter monday": "march 28",
                    "good friday": "march 25",
                    "ascension day": "may 5",
                    eid: "july 6",
                    "eid al-fitr": "july 6",
                    "eid al-adha": "september 11",
                    ramadan: "may 27",
                    diwali: "october 30"
                },
                2017: {
                    "chinese new year": "28 january",
                    easter: "april 16",
                    "easter sunday": "april 16",
                    "easter monday": "april 17",
                    "good friday": "april 14",
                    "ascension day": "may 25",
                    eid: "july 25",
                    "eid al-fitr": "july 25",
                    diwali: "october 21",
                    ramadan: "may 27"
                }
            };
            var thisYear = new Date().getFullYear();
            var holidays = fns.extend(annual, astronomical[thisYear] || {});
            module.exports = holidays;
        }, {
            "../fns": 23
        } ],
        9: [ function(require, module, exports) {
            "use strict";
            module.exports = [ "jr", "mr", "mrs", "ms", "dr", "prof", "sr", "sen", "corp", "rep", "gov", "atty", "supt", "det", "rev", "col", "gen", "lt", "cmdr", "adm", "capt", "sgt", "cpl", "maj", "mister", "sir", "esq", "mstr", "phd", "adj", "adv", "asst", "bldg", "brig", "comdr", "hon", "messrs", "mlle", "mme", "op", "ord", "pvt", "reps", "res", "sens", "sfc", "surg" ];
        }, {} ],
        10: [ function(require, module, exports) {
            "use strict";
            var main = [ [ "child", "_ren" ], [ "person", "people" ], [ "leaf", "leaves" ], [ "database", "_s" ], [ "quiz", "_zes" ], [ "stomach", "_s" ], [ "sex", "_es" ], [ "move", "_s" ], [ "shoe", "_s" ], [ "goose", "geese" ], [ "phenomenon", "phenomena" ], [ "barracks", "_" ], [ "deer", "_" ], [ "syllabus", "syllabi" ], [ "index", "indices" ], [ "appendix", "appendices" ], [ "criterion", "criteria" ], [ "man", "men" ], [ "sex", "_es" ], [ "rodeo", "_s" ], [ "epoch", "_s" ], [ "zero", "_s" ], [ "avocado", "_s" ], [ "halo", "_s" ], [ "tornado", "_s" ], [ "tuxedo", "_s" ], [ "sombrero", "_s" ], [ "addendum", "addenda" ], [ "alga", "_e" ], [ "alumna", "_e" ], [ "alumnus", "alumni" ], [ "bacillus", "bacilli" ], [ "cactus", "cacti" ], [ "beau", "_x" ], [ "château", "_x" ], [ "chateau", "_x" ], [ "tableau", "_x" ], [ "corpus", "corpora" ], [ "curriculum", "curricula" ], [ "echo", "_es" ], [ "embargo", "_es" ], [ "foot", "feet" ], [ "genus", "genera" ], [ "hippopotamus", "hippopotami" ], [ "larva", "_e" ], [ "libretto", "libretti" ], [ "loaf", "loaves" ], [ "matrix", "matrices" ], [ "memorandum", "memoranda" ], [ "mosquito", "_es" ], [ "opus", "opera" ], [ "ovum", "ova" ], [ "ox", "_en" ], [ "radius", "radii" ], [ "referendum", "referenda" ], [ "thief", "thieves" ], [ "tooth", "teeth" ] ];
            main = main.map(function(a) {
                a[1] = a[1].replace("_", a[0]);
                return a;
            });
            module.exports = main;
        }, {} ],
        11: [ function(require, module, exports) {
            "use strict";
            var irregular_verbs = {
                take: {
                    perfect: "have taken",
                    pluperfect: "had taken",
                    future_perfect: "will have taken"
                },
                can: {
                    gerund: "",
                    present: "can",
                    past: "could",
                    future: "can",
                    perfect: "could",
                    pluperfect: "could",
                    future_perfect: "can",
                    actor: ""
                },
                free: {
                    gerund: "freeing",
                    actor: ""
                },
                arise: {
                    past: "arose",
                    participle: "arisen"
                },
                babysit: {
                    past: "babysat",
                    actor: "babysitter"
                },
                be: {
                    past: "been",
                    present: "is",
                    future: "will be",
                    perfect: "have been",
                    pluperfect: "had been",
                    future_perfect: "will have been",
                    actor: "",
                    gerund: "am"
                },
                is: {
                    past: "was",
                    present: "is",
                    future: "will be",
                    perfect: "have been",
                    pluperfect: "had been",
                    future_perfect: "will have been",
                    actor: "",
                    gerund: "being"
                },
                beat: {
                    gerund: "beating",
                    actor: "beater"
                },
                begin: {
                    gerund: "beginning",
                    past: "began"
                },
                bet: {
                    actor: "better"
                },
                bind: {
                    past: "bound"
                },
                bite: {
                    gerund: "biting",
                    past: "bit"
                },
                bleed: {
                    past: "bled"
                },
                "break": {
                    past: "broke"
                },
                breed: {
                    past: "bred"
                },
                bring: {
                    past: "brought"
                },
                broadcast: {
                    past: "broadcast"
                },
                build: {
                    past: "built"
                },
                buy: {
                    past: "bought"
                },
                "catch": {
                    past: "caught"
                },
                choose: {
                    gerund: "choosing",
                    past: "chose"
                },
                cost: {
                    past: "cost"
                },
                deal: {
                    past: "dealt"
                },
                die: {
                    past: "died",
                    gerund: "dying"
                },
                dig: {
                    gerund: "digging",
                    past: "dug"
                },
                "do": {
                    past: "did",
                    present: "does"
                },
                draw: {
                    past: "drew"
                },
                drink: {
                    past: "drank"
                },
                drive: {
                    gerund: "driving",
                    past: "drove"
                },
                eat: {
                    gerund: "eating",
                    past: "ate",
                    actor: "eater"
                },
                fall: {
                    past: "fell"
                },
                feed: {
                    past: "fed"
                },
                feel: {
                    past: "felt",
                    actor: "feeler"
                },
                fight: {
                    past: "fought"
                },
                find: {
                    past: "found"
                },
                fly: {
                    past: "flew"
                },
                forbid: {
                    past: "forbade"
                },
                forget: {
                    gerund: "forgeting",
                    past: "forgot"
                },
                forgive: {
                    gerund: "forgiving",
                    past: "forgave"
                },
                freeze: {
                    gerund: "freezing",
                    past: "froze"
                },
                get: {
                    past: "got"
                },
                give: {
                    gerund: "giving",
                    past: "gave"
                },
                go: {
                    past: "went",
                    present: "goes"
                },
                hang: {
                    past: "hung"
                },
                have: {
                    gerund: "having",
                    past: "had",
                    present: "has"
                },
                hear: {
                    past: "heard"
                },
                hide: {
                    past: "hid"
                },
                hold: {
                    past: "held"
                },
                hurt: {
                    past: "hurt"
                },
                lay: {
                    past: "laid"
                },
                lead: {
                    past: "led"
                },
                leave: {
                    past: "left"
                },
                lie: {
                    gerund: "lying",
                    past: "lay"
                },
                light: {
                    past: "lit"
                },
                lose: {
                    gerund: "losing",
                    past: "lost"
                },
                make: {
                    past: "made"
                },
                mean: {
                    past: "meant"
                },
                meet: {
                    gerund: "meeting",
                    past: "met",
                    actor: "meeter"
                },
                pay: {
                    past: "paid"
                },
                read: {
                    past: "read"
                },
                ring: {
                    past: "rang"
                },
                rise: {
                    past: "rose"
                },
                run: {
                    gerund: "running",
                    past: "ran"
                },
                say: {
                    past: "said"
                },
                see: {
                    past: "saw"
                },
                sell: {
                    past: "sold"
                },
                shine: {
                    past: "shone"
                },
                shoot: {
                    past: "shot"
                },
                show: {
                    past: "showed"
                },
                sing: {
                    past: "sang"
                },
                sink: {
                    past: "sank",
                    pluperfect: "had sunk"
                },
                sit: {
                    past: "sat"
                },
                slide: {
                    past: "slid"
                },
                speak: {
                    past: "spoke",
                    perfect: "have spoken",
                    pluperfect: "had spoken",
                    future_perfect: "will have spoken"
                },
                spin: {
                    gerund: "spinning",
                    past: "spun"
                },
                spread: {
                    past: "spread"
                },
                stand: {
                    past: "stood"
                },
                steal: {
                    past: "stole",
                    actor: "stealer"
                },
                stick: {
                    past: "stuck"
                },
                sting: {
                    past: "stung"
                },
                stream: {
                    actor: "streamer"
                },
                strike: {
                    gerund: "striking",
                    past: "struck"
                },
                swear: {
                    past: "swore"
                },
                swim: {
                    past: "swam"
                },
                swing: {
                    past: "swung"
                },
                teach: {
                    past: "taught",
                    present: "teaches"
                },
                tear: {
                    past: "tore"
                },
                tell: {
                    past: "told"
                },
                think: {
                    past: "thought"
                },
                understand: {
                    past: "understood"
                },
                wake: {
                    past: "woke"
                },
                wear: {
                    past: "wore"
                },
                win: {
                    gerund: "winning",
                    past: "won"
                },
                withdraw: {
                    past: "withdrew"
                },
                write: {
                    gerund: "writing",
                    past: "wrote"
                },
                tie: {
                    gerund: "tying",
                    past: "tied"
                },
                ski: {
                    past: "skiied"
                },
                boil: {
                    actor: "boiler"
                },
                miss: {
                    present: "miss"
                },
                act: {
                    actor: "actor"
                },
                compete: {
                    gerund: "competing",
                    past: "competed",
                    actor: "competitor"
                },
                being: {
                    gerund: "are",
                    past: "were",
                    present: "are"
                },
                imply: {
                    past: "implied",
                    present: "implies"
                },
                ice: {
                    gerund: "icing",
                    past: "iced"
                },
                develop: {
                    past: "developed",
                    actor: "developer",
                    gerund: "developing"
                },
                wait: {
                    gerund: "waiting",
                    past: "waited",
                    actor: "waiter"
                },
                aim: {
                    actor: "aimer"
                },
                spill: {
                    past: "spilt"
                },
                drop: {
                    gerund: "dropping",
                    past: "dropped"
                },
                log: {
                    gerund: "logging",
                    past: "logged"
                },
                rub: {
                    gerund: "rubbing",
                    past: "rubbed"
                },
                smash: {
                    present: "smashes"
                },
                suit: {
                    gerund: "suiting",
                    past: "suited",
                    actor: "suiter"
                }
            };
            module.exports = irregular_verbs;
        }, {} ],
        12: [ function(require, module, exports) {
            "use strict";
            var misc = {
                there: "NN",
                here: "JJ",
                better: "JJR",
                earlier: "JJR",
                has: "VB",
                sounds: "VBZ",
                taken: "VBD",
                msg: "VB",
                noon: "DA",
                midnight: "DA",
                now: "DA",
                morning: "DA",
                evening: "DA",
                afternoon: "DA",
                ago: "DA",
                eod: "DA",
                eom: "DA",
                number: "NN",
                system: "NN",
                example: "NN",
                part: "NN",
                house: "NN"
            };
            var compact = {
                CC: [ "yet", "therefore", "or", "while", "nor", "whether", "though", "because", "cuz", "but", "for", "and", "however", "before", "although", "how", "plus", "versus", "not" ],
                CO: [ "if", "unless", "otherwise", "notwithstanding" ],
                VBD: [ "said", "had", "been", "began", "came", "did", "meant", "went" ],
                VBN: [ "given", "known", "shown", "seen", "born" ],
                VBG: [ "going", "being", "according", "resulting", "developing", "staining" ],
                CP: [ "is", "will be", "are", "was", "were", "am", "isn't", "ain't", "aren't" ],
                DT: [ "this", "any", "enough", "each", "whatever", "every", "which", "these", "another", "plenty", "whichever", "neither", "an", "a", "least", "own", "few", "both", "those", "the", "that", "various", "what", "either", "much", "some", "else", "no", "la", "le", "les", "des", "de", "du", "el" ],
                IN: [ "until", "onto", "of", "into", "out", "except", "across", "by", "between", "at", "down", "as", "from", "around", "with", "among", "upon", "amid", "to", "along", "since", "about", "off", "on", "within", "in", "during", "per", "without", "throughout", "through", "than", "via", "up", "unlike", "despite", "below", "unless", "towards", "besides", "after", "whereas", "'o", "amidst", "amongst", "apropos", "atop", "barring", "chez", "circa", "mid", "midst", "notwithstanding", "qua", "sans", "vis-a-vis", "thru", "till", "versus", "without", "w/o", "o'", "a'" ],
                MD: [ "can", "may", "could", "might", "will", "ought to", "would", "must", "shall", "should", "ought", "shant", "lets" ],
                PP: [ "mine", "something", "none", "anything", "anyone", "theirs", "himself", "ours", "his", "my", "their", "yours", "your", "our", "its", "herself", "hers", "themselves", "myself", "itself", "her", "who", "whom", "whose" ],
                PRP: [ "it", "they", "i", "them", "you", "she", "me", "he", "him", "ourselves", "us", "we", "thou", "il", "elle", "yourself", "'em", "he's", "she's" ],
                RB: [ "again", "already", "soon", "directly", "toward", "forever", "apart", "instead", "yes", "alone", "indeed", "ever", "quite", "perhaps", "where", "then", "thus", "very", "often", "once", "never", "why", "when", "away", "always", "sometimes", "also", "maybe", "so", "just", "well", "several", "such", "randomly", "too", "rather", "abroad", "almost", "anyway", "twice", "aside", "moreover", "anymore", "newly", "damn", "somewhat", "somehow", "meanwhile", "hence", "further", "furthermore", "more", "way", "kinda", "totally" ],
                EX: [ "uh", "uhh", "uh huh", "uh-oh", "please", "ugh", "sheesh", "eww", "pff", "voila", "oy", "hi", "hello", "bye", "goodbye", "hey", "hai", "eep", "hurrah", "yuck", "ow", "duh", "oh", "hmm", "yeah", "whoa", "ooh", "whee", "ah", "bah", "gah", "yaa", "phew", "gee", "ahem", "eek", "meh", "yahoo", "oops", "d'oh", "psst", "argh", "grr", "nah", "shhh", "whew", "mmm", "ooo", "yay", "uh-huh", "boo", "wow", "nope", "haha", "hahaha", "lol", "lols", "ya", "hee", "ohh", "eh", "yup" ],
                NN: [ "nothing", "everything", "god", "student", "patent", "funding", "banking", "ceiling", "energy", "purpose", "friend", "event", "room", "door", "thing", "things", "stuff", "lunch", "breakfast", "dinner", "home", "problem", "body", "world", "city", "death", "others" ],
                PN: [ "father", "mother", "mom", "dad", "mommy", "daddy", "sister", "brother", "aunt", "uncle", "grandfather", "grandmother", "cousin", "stepfather", "stepmother", "boy", "girl", "man", "men", "woman", "women", "guy", "dude", "bro", "gentleman", "someone" ]
            };
            var keys = Object.keys(compact);
            for (var i = 0; i < keys.length; i++) {
                var arr = compact[keys[i]];
                for (var i2 = 0; i2 < arr.length; i2++) {
                    misc[arr[i2]] = keys[i];
                }
            }
            module.exports = misc;
        }, {} ],
        13: [ function(require, module, exports) {
            "use strict";
            module.exports = {
                "a few": "CD",
                "of course": "RB",
                "at least": "RB",
                "no longer": "RB",
                "sort of": "RB",
                "once again": "RB",
                "once more": "RB",
                "up to": "RB",
                "by now": "RB",
                "all but": "RB",
                "just about": "RB",
                "so called": "JJ",
                "on board": "JJ",
                "a lot": "RB",
                "by far": "RB",
                "at best": "RB",
                "at large": "RB",
                "for good": "RB",
                "for example": "RB",
                "vice versa": "JJ",
                "en route": "JJ",
                "for sure": "RB",
                "upside down": "JJ",
                "at most": "RB",
                "per se": "RB",
                "at worst": "RB",
                "upwards of": "RB",
                "en masse": "RB",
                "point blank": "RB",
                "up front": "JJ",
                "in front": "JJ",
                "in situ": "JJ",
                "in vitro": "JJ",
                "ad hoc": "JJ",
                "de facto": "JJ",
                "ad infinitum": "JJ",
                "ad nauseam": "RB",
                "for keeps": "JJ",
                "a priori": "JJ",
                "et cetera": "IN",
                "off guard": "JJ",
                "spot on": "JJ",
                "ipso facto": "JJ",
                "not withstanding": "RB",
                "de jure": "RB",
                "a la": "IN",
                "ad hominem": "NN",
                "par excellence": "RB",
                "de trop": "RB",
                "a posteriori": "RB",
                "fed up": "JJ",
                "brand new": "JJ",
                "old fashioned": "JJ",
                "bona fide": "JJ",
                "well off": "JJ",
                "far off": "JJ",
                "straight forward": "JJ",
                "hard up": "JJ",
                "sui generis": "JJ",
                "en suite": "JJ",
                "avant garde": "JJ",
                "sans serif": "JJ",
                "gung ho": "JJ",
                "super duper": "JJ",
                "new york": "NN",
                "new england": "NN",
                "new hampshire": "NN",
                "new delhi": "NN",
                "new jersey": "NN",
                "new mexico": "NN",
                "united states": "NN",
                "united kingdom": "NN",
                "great britain": "NN",
                "head start": "NN",
                "make sure": "VB",
                "keep tabs": "VB",
                "credit card": "NN",
                "standard time": "DA",
                "daylight time": "DA",
                "summer time": "DA",
                "fl oz": "NN",
                "us dollar": "NN"
            };
        }, {} ],
        14: [ function(require, module, exports) {
            "use strict";
            var fns = require("../../fns");
            var arr = [ "abby", "amy", "autumn", "bobbi", "brooke", "carol", "cheryl", "claire", "cleo", "consuelo", "eleanor", "eliza", "erika", "faye", "fern", "genevieve", "gertrude", "gladys", "inez", "ingrid", "jenny", "jo", "joni", "kathryn", "kelli", "kim", "latoya", "leigh", "lupe", "luz", "lynn", "mae", "maude", "mildred", "miriam", "naomi", "nikki", "olga", "reba", "robyn", "rosalind", "ruth", "sheryl", "socorro", "sonja", "staci", "tanya", "therese", "toni", "traci", "vicki", "vicky" ];
            var suffix_compressed = {
                nette: "an,antoi,ja,jea,jean,ly",
                eline: "ad,ang,jacqu,mad",
                rlene: "a,cha,da,ma",
                stine: "chri,erne,ju,kri",
                tasha: "la,na,",
                andra: "alex,cass,s",
                helle: "mic,rac,roc",
                linda: "be,,me",
                stina: "chri,cri,kri",
                annie: ",f,je",
                anne: ",di,je,jo,le,mari,rox,sus,suz",
                elia: "am,ang,cec,c,corn,d,of,sh",
                llie: "ca,ke,li,mi,mo,ne,o,sa",
                anna: ",de,di,jo,joh,sh",
                ette: "bernad,b,bridg,claud,paul,yv",
                ella: "d,,est,lu,marc,st",
                nnie: "bo,co,je,mi,wi",
                elle: "dani,est,gabri,isab,jan",
                icia: "al,fel,let,patr,tr",
                leen: "ai,cath,col,ei,kath",
                elma: ",s,th,v",
                etta: ",henri,lor,ros",
                anie: "j,mel,stef,steph",
                anda: "am,mir,w,yol",
                arla: "c,d,k,m",
                lena: "e,he,,magda",
                rina: "kat,ma,sab,t",
                isha: "al,ke,lat,tr",
                olly: "d,m,p",
                rice: "beat,cla,pat",
                ttie: "be,ma,ne",
                acie: "gr,st,tr",
                isty: "chr,kr,m",
                dith: "e,ju,mere",
                onya: "lat,s,t",
                onia: "ant,s,t",
                erri: "k,sh,t",
                lisa: "a,e,",
                rine: "cathe,katha,kathe",
                nita: "a,bo,jua",
                elyn: "ev,jacqu,joc",
                nine: "ja,jea,jean",
                nice: "ber,eu,ja",
                tney: "brit,cour,whi",
                ssie: "be,ca,e",
                beth: ",elisa,eliza",
                ine: "carol,ela,franc,gerald,jasm,joseph,lorra,max,nad,paul",
                ana: "adri,,d,de,di,j,ju,l,sh,sus",
                rie: "car,che,lau,lo,ma,marjo,rosema,sher,vale",
                ina: "angel,carol,d,georg,g,josef,mart,n,t",
                ora: "c,deb,d,fl,len,l,n,",
                ara: "barb,c,cl,k,l,s,tam,t",
                ela: "ang,carm,gabri,graci,l,manu,pam",
                ica: "angel,er,jess,mon,patr,veron",
                nda: "bre,gle,luci,ly,rho,ro",
                ley: "ash,kel,kimber,les,shel,shir",
                eri: "ch,j,k,sh,t",
                ndy: "ci,ma,mi,sa,we",
                ene: "hel,imog,ir,jol,lor",
                ula: "e,l,pa,urs",
                ann: ",jo,le,mary",
                ola: "le,l,,vi",
                nna: "do,gle,je,lado",
                nne: "adrie,cori,ly,yvo",
                lie: "ju,les,nata,rosa",
                ise: "den,el,elo,lou",
                die: "ad,gol,jo,sa",
                ena: "d,lor,r,she",
                ian: "jill,lill,mar,viv",
                lyn: "caro,gwendo,jac,mari",
                ssa: "aly,mari,meli,vane",
                thy: "ca,doro,dor,ka",
                tha: "ber,mar,saman,tabi",
                sie: "el,jo,ro,su",
                bel: "isa,ma,mari",
                via: "oli,sil,syl",
                tie: "chris,ka,kris",
                dra: "au,ken,son",
                ria: "glo,ma,victo",
                gie: "an,mag,mar",
                lly: "ke,sa,she",
                ila: "le,l,she",
                rna: "lo,my,ve",
                ole: "car,nich,nic",
                rma: "e,i,no",
                any: "beth,britt,tiff",
                ona: "le,m,ram",
                rta: "albe,ma,robe",
                en: "carm,dore,ell,gretch,gw,hel,kar,kirst,krist,laur,maure",
                ia: "cecil,claud,cynth,eugen,georg,jul,luc,lyd,marc,soph,virgin",
                le: "ade,camil,ceci,ga,gay,luci,lucil,mab,miche,myrt",
                ie: "bobb,debb,dix,eff,jack,lizz,mam,soph,tamm,vick",
                ra: "barb,deb,elvi,lau,may,my,pet,ve",
                er: "amb,est,esth,heath,jenif,jennif,summ",
                da: "a,ai,fre,frie,hil,i,matil",
                ce: "ali,canda,candi,constan,floren,gra,joy",
                ah: "beul,debor,hann,le,rebek,sar",
                sa: "el,lui,mari,ro,tere,there",
                ne: "daph,dia,ja,jay,laver,simo",
                el: "eth,laur,muri,racha,rach,raqu",
                is: "delor,dor,jan,lo,mav,phyll",
                et: "bridg,harri,jan,margar,margr",
                ta: "al,chris,kris,margari,ri",
                es: "agn,delor,dolor,franc,merced",
                an: "jo,meag,meg,megh,sus",
                cy: "lu,mar,nan,sta,tra",
                "in": "caitl,er,kar,krist",
                ey: "audr,linds,stac,trac",
                ca: "bian,blan,francis,rebec",
                on: "alis,allis,shann,shar",
                il: "abiga,apr,ga,syb",
                ly: "bever,emi,kimber,li",
                ea: "andr,chels,doroth,l",
                ee: "aim,d,desir,ren",
                ma: "al,em,wil",
                di: "bran,hei,jo",
                va: "el,e,i",
                ue: "dominiq,moniq,s",
                ay: "f,k,linds",
                te: "celes,ka,margueri",
                ry: "ma,rosema,sher",
                na: "ed,shau,shaw",
                dy: "jo,ju,tru",
                ti: "chris,kris,pat",
                sy: "bet,dai,pat",
                ri: "ka,lo,sha",
                la: "kay,priscil,wil",
                al: "cryst,kryst,op",
                ll: "jewe,ji,ne"
            };
            arr = fns.expand_suffixes(arr, suffix_compressed);
            var prefix_compressed = {
                mar: "go,isol,itza,sha",
                tam: "i,ika,my",
                be: "atriz,cky,tty,ttye",
                pe: "arl,ggy,nny",
                pa: "ige,m,tty"
            };
            arr = fns.expand_prefixes(arr, prefix_compressed);
            module.exports = arr;
        }, {
            "../../fns": 23
        } ],
        15: [ function(require, module, exports) {
            "use strict";
            var fns = require("../../fns");
            var arr = [ "adolfo", "angelo", "anthony", "armand", "arthur", "bill", "billy", "bobby", "bradford", "bret", "caleb", "carroll", "cliff", "clifford", "craig", "curt", "derek", "doug", "dwight", "edmund", "eli", "elliot", "enrique", "erik", "felipe", "felix", "francisco", "frank", "george", "glenn", "greg", "gregg", "hans", "hugh", "ira", "irving", "isaac", "jim", "kermit", "kurt", "leo", "levi", "lorenzo", "lou", "pablo", "pat", "percy", "philip", "phillip", "rex", "ricky", "shaun", "shawn", "sterling", "steve", "tim", "timothy", "wilbur", "williams", "wm", "woodrow" ];
            var suffix_compressed = {
                rence: "cla,lau,law,te,ter",
                lbert: "a,de,e,gi,wi",
                ustin: "ag,a,d,j",
                berto: "al,gil,hum,ro",
                ester: "ch,l,sylv",
                onnie: "d,l,r",
                wayne: "de,d,",
                erick: ",fred,rod",
                athan: "john,jon,n",
                elvin: ",k,m",
                anuel: "em,emm,m",
                bert: ",her,hu,nor,ro",
                rick: "der,fred,kend,pat,",
                land: "cleve,gar,le,ro",
                ando: "arm,fern,orl,rol",
                ardo: "edu,ger,leon,ric",
                lton: "a,car,e,mi",
                arry: "b,g,h,l",
                nton: "a,cli,qui",
                fred: "al,,wil",
                ance: "l,terr,v",
                mmie: "ji,sa,to",
                erry: "j,p,t",
                mond: "des,ed,ray",
                rman: "he,no,she",
                rvin: "e,i,ma",
                nald: "do,regi,ro",
                rett: "b,eve,gar",
                son: "harri,jack,ja,ma,nel,ty,wil",
                ell: "darn,darr,low,mitch,russ,terr,wend",
                ard: "bern,edw,ger,how,leon,rich,will",
                ian: "adr,br,christ,dam,fab,,jul",
                don: "bran,,el,gor,shel",
                ron: "aa,by,came,my,",
                ton: "bur,clay,clif,pres,wins",
                lan: "a,al,dy,har,no",
                rey: "ca,co,geoff,jeff",
                ent: "br,k,tr,vinc",
                ael: "ism,mich,raf,raph",
                mmy: "ji,sa,ti,to",
                mon: "da,ra,si,solo",
                las: "dal,doug,nicho,nico",
                vin: "al,cal,de,ke",
                nny: "be,da,joh,ke",
                ius: "cornel,dar,demetr,jul",
                ley: "brad,har,stan,wes",
                lio: "emi,ju,roge",
                ben: ",reu,ru",
                ory: "c,greg,r",
                lie: "bil,char,wil",
                van: "e,i,",
                roy: "le,,t",
                all: "kend,marsh,rand",
                ary: "c,g,zach",
                ddy: "bu,fre,te",
                art: "b,stew,stu",
                iel: "dan,gabr,nathan",
                lin: "co,frank,mar",
                yle: "do,k,l",
                her: "christop,kristop,lut",
                oyd: "b,fl,ll",
                ren: "dar,lo,war",
                ter: "dex,pe,wal",
                arl: "c,e,k",
                ane: "d,du,sh",
                aul: "p,r,s",
                dan: "bren,,jor",
                nie: "ben,er,john",
                ine: "anto,bla,jerma",
                lph: "ra,rando,rudo",
                est: "earn,ern,forr",
                win: "dar,ed,er",
                is: "chr,curt,den,denn,ell,franc,lew,lou,lu,morr,ot,trav,will",
                er: "alexand,elm,grov,hom,jasp,javi,oliv,rodg,rog,spenc,tyl,xavi",
                an: "bry,de,esteb,eth,ju,log,rom,ry,se,st,steph",
                el: "ab,darr,fid,jo,lion,marc,mich,migu,no,russ,samu",
                "in": "benjam,bra,dar,darr,efra,joaqu,mart,quent",
                ie: "arch,edd,frank,fredd,lou,regg,robb",
                en: "all,dami,gl,k,ow,steph,stev",
                ey: "dew,harv,jo,mick,rick,rodn,sidn",
                al: ",h,jam,miche,ne,rand",
                on: "bry,j,jonath,le,marl,vern",
                or: "hect,juni,salvad,tayl,trev,vict",
                dy: "an,bra,co,gra,ran,ru",
                ce: "bru,bry,hora,mauri,roy,walla",
                il: "cec,em,ne,ph,virg",
                ar: "ces,edg,lam,om,osc",
                es: "andr,charl,jam,mil,mos",
                ro: "alejand,alva,artu,ped,rami",
                am: "abrah,ad,grah,s,willi",
                ck: "chu,domini,ja,ma,ni",
                io: "anton,gregor,ignac,mar,serg",
                ah: "elij,jeremi,mic,no",
                nt: "brya,cli,gra,lamo",
                re: "and,pier,salvato,theodo",
                ed: ",jar,n,t",
                ld: "arno,gera,haro,jera",
                as: "eli,luc,thom,tom",
                os: "am,carl,marc,sant",
                ew: "andr,dr,math,matth",
                ke: "bla,ja,lu,mi",
                tt: "ellio,emme,ma,sco",
                ty: "mar,mon,rus,scot",
                th: "hea,kei,kenne,se",
                ay: "cl,j,murr,r",
                le: "da,mer,orvil",
                te: "mon,pe,vicen",
                us: "jes,marc,ruf",
                od: "elwo,jarr,r",
                ob: "b,jac,r",
                to: "beni,ernes,ot",
                ne: "euge,ge,tyro",
                go: "domin,hu,santia",
                de: "clau,cly,wa",
                "do": "alfre,reynal,wilfre",
                rk: "cla,ki,ma",
                se: "cha,jes,jo",
                ry: "hen,jeffe,jeff",
                ic: "cedr,domin,er",
                ad: "br,ch,conr"
            };
            arr = fns.expand_suffixes(arr, suffix_compressed);
            var prefix_compressed = {
                jos: "eph,h,hua",
                ro: "cky,dolfo,osevelt,scoe,ss",
                je: "ff,remy,rome,ss",
                to: "by,dd,m,ny",
                da: "rryl,ryl,ve,vid",
                jo: "e,esph,hn,rge",
                ma: "lcolm,rc,rco,x",
                al: "ex,fonso,i,onzo",
                gu: "illermo,stavo,y"
            };
            arr = fns.expand_prefixes(arr, prefix_compressed);
            module.exports = arr;
        }, {
            "../../fns": 23
        } ],
        16: [ function(require, module, exports) {
            "use strict";
            var cardinal = {
                ones: {
                    a: 1,
                    zero: 0,
                    one: 1,
                    two: 2,
                    three: 3,
                    four: 4,
                    five: 5,
                    six: 6,
                    seven: 7,
                    eight: 8,
                    nine: 9
                },
                teens: {
                    ten: 10,
                    eleven: 11,
                    twelve: 12,
                    thirteen: 13,
                    fourteen: 14,
                    fifteen: 15,
                    sixteen: 16,
                    seventeen: 17,
                    eighteen: 18,
                    nineteen: 19
                },
                tens: {
                    twenty: 20,
                    thirty: 30,
                    forty: 40,
                    fifty: 50,
                    sixty: 60,
                    seventy: 70,
                    eighty: 80,
                    ninety: 90
                },
                multiples: {
                    hundred: 100,
                    grand: 1e3,
                    thousand: 1e3,
                    million: 1e6,
                    billion: 1e9,
                    trillion: 1e12,
                    quadrillion: 1e15,
                    quintillion: 1e18,
                    sextillion: 1e21,
                    septillion: 1e24
                }
            };
            var ordinal = {
                ones: {
                    first: 1,
                    second: 2,
                    third: 3,
                    fourth: 4,
                    fifth: 5,
                    sixth: 6,
                    seventh: 7,
                    eighth: 8,
                    ninth: 9
                },
                teens: {
                    tenth: 10,
                    eleventh: 11,
                    twelfth: 12,
                    thirteenth: 13,
                    fourteenth: 14,
                    fifteenth: 15,
                    sixteenth: 16,
                    seventeenth: 17,
                    eighteenth: 18,
                    nineteenth: 19
                },
                tens: {
                    twentieth: 20,
                    thirtieth: 30,
                    fourtieth: 40,
                    fiftieth: 50,
                    sixtieth: 60,
                    seventieth: 70,
                    eightieth: 80,
                    ninetieth: 90
                },
                multiples: {
                    hundredth: 100,
                    thousandth: 1e3,
                    millionth: 1e6,
                    billionth: 1e9,
                    trillionth: 1e12,
                    quadrillionth: 1e15,
                    quintillionth: 1e18,
                    sextillionth: 1e21,
                    septillionth: 1e24
                }
            };
            var prefixes = {
                yotta: 1,
                zetta: 1,
                exa: 1,
                peta: 1,
                tera: 1,
                giga: 1,
                mega: 1,
                kilo: 1,
                hecto: 1,
                deka: 1,
                deci: 1,
                centi: 1,
                milli: 1,
                micro: 1,
                nano: 1,
                pico: 1,
                femto: 1,
                atto: 1,
                zepto: 1,
                yocto: 1,
                square: 1,
                cubic: 1,
                quartic: 1
            };
            module.exports = {
                ones: cardinal.ones,
                teens: cardinal.teens,
                tens: cardinal.tens,
                multiples: cardinal.multiples,
                ordinal_ones: ordinal.ones,
                ordinal_teens: ordinal.teens,
                ordinal_tens: ordinal.tens,
                ordinal_multiples: ordinal.multiples,
                prefixes: prefixes
            };
        }, {} ],
        17: [ function(require, module, exports) {
            "use strict";
            var organizations = [ "google", "microsoft", "walmart", "exxonmobil", "glencore", "samsung", "chevron", "at&t", "verizon", "costco", "nestlé", "7-eleven", "adidas", "nike", "acer", "mcdonalds", "mcdonald's", "comcast", "compaq", "craigslist", "cisco", "disney", "coca cola", "dupont", "ebay", "facebook", "fedex", "kmart", "kkk", "kodak", "monsanto", "myspace", "netflix", "sony", "telus", "twitter", "usps", "ubs", "ups", "walgreens", "youtube", "yahoo!", "yamaha" ];
            var suffixes = [ "center", "centre", "memorial", "school", "government", "faculty", "society", "union", "ministry", "collective", "association", "committee", "university", "bank", "college", "foundation", "department", "institute", "club", "co", "sons" ];
            module.exports = {
                suffixes: suffixes,
                organizations: organizations
            };
        }, {} ],
        18: [ function(require, module, exports) {
            "use strict";
            var verb_conjugate = require("../term/verb/conjugate/conjugate.js");
            var main = [ "be onto", "fall behind", "fall through", "fool with", "get across", "get along", "get at", "give way", "hear from", "hear of", "lash into", "make do", "run across", "set upon", "take aback", "keep from" ];
            var opposites = {
                away: "back",
                "in": "out",
                on: "off",
                over: "under",
                together: "apart",
                up: "down"
            };
            var symmetric = {
                away: "blow,bounce,bring,call,come,cut,drop,fire,get,give,go,keep,pass,put,run,send,shoot,switch,take,tie,throw",
                "in": "bang,barge,bash,beat,block,book,box,break,bring,burn,butt,carve,cash,check,come,cross,drop,fall,fence,fill,give,grow,hand,hang,head,jack,keep,leave,let,lock,log,move,opt,pack,peel,pull,put,reach,ring,rub,send,set,settle,shut,sign,smash,snow,strike,take,try,turn,type,warm,wave,wean,wear,wheel",
                on: "add,call,carry,catch,count,feed,get,give,go,grind,head,hold,keep,lay,log,pass,pop,power,put,send,show,snap,switch,take,tell,try,turn,wait",
                over: "come,go,look,read,run,talk",
                together: "come,pull,put",
                up: "add,back,beat,bend,blow,boil,bottle,break,bring,buckle,bundle,call,carve,clean,cut,dress,fill,flag,fold,get,give,grind,grow,hang,hold,keep,let,load,lock,look,man,mark,melt,move,pack,pin,pipe,plump,pop,power,pull,put,rub,scale,scrape,send,set,settle,shake,show,sit,slow,smash,square,stand,strike,take,tear,tie,turn,use,wash,wind"
            };
            Object.keys(symmetric).forEach(function(k) {
                symmetric[k].split(",").forEach(function(s) {
                    main.push(s + " " + k);
                    main.push(s + " " + opposites[k]);
                });
            });
            var asymmetric = {
                about: "bring,fool,gad,go,root,mess",
                after: "go,look,take",
                ahead: "get,go,press",
                along: "bring,move",
                apart: "fall,take",
                around: "ask,boss,bring,call,come,fool,get,horse,joke,lie,mess,play",
                away: "back,carry,file,frighten,hide,wash",
                back: "fall,fight,hit,hold,look,pay,stand,think",
                by: "come,drop,get,go,stop,swear,swing,tick,zip",
                down: "bog,calm,fall,hand,hunker,jot,knock,lie,narrow,note,pat,pour,run,tone,trickle,wear",
                "for": "fend,file,gun,hanker,root,shoot",
                forth: "bring,come",
                forward: "come,look",
                "in": "cave,chip,hone,jump,key,pencil,plug,rein,shade,sleep,stop,suck,tie,trade,tuck,usher,weigh,zero",
                into: "look,run",
                it: "go,have",
                off: "auction,be,beat,blast,block,brush,burn,buzz,cast,cool,drop,end,face,fall,fend,frighten,goof,jack,kick,knock,laugh,level,live,make,mouth,nod,pair,pay,peel,read,reel,ring,rip,round,sail,shave,shoot,sleep,slice,split,square,stave,stop,storm,strike,tear,tee,tick,tip,top,walk,work,write",
                on: "bank,bargain,frown,hit,latch,pile,prattle,press,spring,spur,tack,urge,yammer",
                out: "act,ask,back,bail,bear,black,blank,bleed,blow,blurt,branch,buy,cancel,cut,eat,edge,farm,figure,find,fill,find,fish,fizzle,flake,flame,flare,flesh,flip,geek,get,help,hide,hold,iron,knock,lash,level,listen,lose,luck,make,max,miss,nerd,pan,pass,pick,pig,point,print,psych,rat,read,rent,root,rule,run,scout,see,sell,shout,single,sit,smoke,sort,spell,splash,stamp,start,storm,straighten,suss,time,tire,top,trip,trot,wash,watch,weird,whip,wimp,wipe,work,zone,zonk",
                over: "bend,bubble,do,fall,get,gloss,hold,keel,mull,pore,sleep,spill,think,tide,tip",
                round: "get,go",
                through: "go,run",
                to: "keep,see",
                up: "act,beef,board,bone,boot,brighten,build,buy,catch,cheer,cook,end,eye,face,fatten,feel,fess,finish,fire,firm,flame,flare,free,freeze,freshen,fry,fuel,gang,gear,goof,hack,ham,heat,hit,hole,hush,jazz,juice,lap,light,lighten,line,link,listen,live,loosen,make,mash,measure,mess,mix,mock,mop,muddle,open,own,pair,patch,pick,prop,psych,read,rough,rustle,save,shack,sign,size,slice,slip,snap,sober,spark,split,spruce,stack,start,stay,stir,stitch,straighten,string,suck,suit,sum,team,tee,think,tidy,tighten,toss,trade,trip,type,vacuum,wait,wake,warm,weigh,whip,wire,wise,word,write,zip"
            };
            Object.keys(asymmetric).forEach(function(k) {
                asymmetric[k].split(",").forEach(function(s) {
                    main.push(s + " " + k);
                });
            });
            main = main.reduce(function(h, s) {
                h[s] = "VBP";
                return h;
            }, {});
            var tags = {
                present: "VB",
                past: "VBD",
                future: "VBF",
                gerund: "VBG",
                infinitive: "VBP"
            };
            var cache = {};
            var split = undefined, verb = undefined, particle = undefined, phrasal = undefined;
            Object.keys(main).forEach(function(s) {
                split = s.split(" ");
                verb = split[0];
                particle = split[1];
                if (cache[verb] === undefined) {
                    cache[verb] = verb_conjugate(verb);
                }
                Object.keys(cache[verb]).forEach(function(k) {
                    phrasal = cache[verb][k] + " " + particle;
                    if (tags[k]) {
                        main[phrasal] = tags[k];
                    }
                });
            });
            module.exports = main;
        }, {
            "../term/verb/conjugate/conjugate.js": 98
        } ],
        19: [ function(require, module, exports) {
            "use strict";
            var fns = require("../fns");
            var countries = [ "usa", "u.s.a.", "ussr", "brazil", "bangladesh", "mexico", "vietnam", "egypt", "germany", "turkey", "france", "united kingdom", "italy", "kenya", "iraq", "morocco", "peru", "yemen", "mozambique", "sri lanka", "burkina faso", "niger", "netherlands", "chile", "malawi", "ecuador", "côte d'ivoire", "mali", "zimbabwe", "chad", "belgium", "cuba", "greece", "haiti", "burundi", "hungary", "sweden", "honduras", "israel", "laos", "el salvador", "libya", "nicaragua", "denmark", "congo-brazzaville", "kuwait", "moldova", "panama", "jamaica", "lesotho", "guinea-bissau", "timor-leste", "djibouti", "fiji", "comoros", "solomon islands", "luxembourg", "suriname", "cape verde", "malta", "bahamas" ];
            var compressed_countries = {
                istan: "pak,uzbek,afghan,tajik,turkmen",
                ublic: "czech rep,dominican rep,central african rep",
                uinea: "g,papua new g,equatorial g",
                land: "thai,po,switzer,fin,republic of ire,new zea,swazi,ice",
                ania: "tanz,rom,maurit,lithu,alb",
                rica: "ame,united states of ame,south af,costa ",
                mbia: "colo,za,ga",
                eria: "nig,alg,lib",
                nia: "arme,macedo,slove,esto",
                sia: "indone,rus,malay,tuni",
                ina: "ch,argent,bosnia and herzegov",
                tan: "kazakhs,kyrgyzs,bhu",
                ana: "gh,botsw,guy",
                bia: "saudi ara,ser,nami",
                lia: "austra,soma,mongo",
                rea: "south ko,north ko,erit",
                dan: "su,south su,jor",
                ria: "sy,aust,bulga",
                ia: "ind,ethiop,cambod,boliv,slovak,georg,croat,latv",
                an: "jap,ir,taiw,azerbaij,om",
                da: "ugan,cana,rwan",
                us: "belar,mauriti,cypr",
                al: "nep,seneg,portug",
                "in": "spa,ben,bahra",
                go: "dr con,to,trinidad-toba",
                la: "venezue,ango,guatema",
                es: "united stat,philippin,united arab emirat",
                on: "camero,leban,gab",
                ar: "myanm,madagasc,qat",
                ay: "paragu,norw,urugu",
                ne: "ukrai,sierra leo,palesti"
            };
            countries = fns.expand_suffixes(countries, compressed_countries);
            var cities = [ "guangzhou", "ahmedabad", "phoenix", "jakarta", "curitiba", "moscow", "tokyo", "nagoya", "kobe", "mexico", "cebu", "ho chi minh", "hanoi", "giza", "frankfurt", "stuttgart", "i̇zmir", "paris", "toulouse", "nice", "rome", "palermo", "genoa", "cape town", "port elizabeth", "bogotá", "medellín", "seville", "zaragoza", "kiev", "odessa", "rosario", "la plata", "warsaw", "kraków", "łódź", "wrocław", "poznań", "calgary", "ottawa", "sydney", "perth", "homs", "iași", "cluj-napoca", "almaty", "the hague", "utrecht", "phnom penh", "antwerp", "ghent", "brussels", "tunis", "athens", "thessaloniki", "prague", "brno", "miskolc", "stockholm", "västerås", "tegucigalpa", "graz", "innsbruck", "abu dhabi", "haifa", "ashdod", "dushanbe", "niš", "aqaba", "aalborg", "helsinki", "espoo", "vantaa", "turku", "košice", "ashgabat", "oslo", "trondheim", "auckland", "tbilisi", "zagreb", "split", "kuwait", "montevideo", "klaipėda", "doha", "skopje", "riga", "luxembourg", "reykjavik", "kingston" ];
            var suffix_compressed_cities = {
                burg: "saint peters,yekaterin,ham,til,gothen,salz",
                ton: "hous,edmon,welling,hamil",
                ion: "hauts-bassins reg,nord reg,herakl",
                ana: "hav,tir,ljublj",
                ara: "guadalaj,ank,timișo",
                an: "tehr,mil,durb,bus,tain,abidj,amm,yerev",
                ia: "philadelph,brasíl,alexandr,pretor,valenc,sof,nicos",
                on: "ly,lond,yang,inche,daeje,lisb",
                en: "shenzh,eindhov,pils,copenhag,berg",
                ng: "beiji,chittago,pyongya,kaohsiu,taichu",
                "in": "tianj,berl,tur,dubl,duned",
                es: "los angel,nant,napl,buenos air,f",
                la: "pueb,mani,barranquil,kampa,guatema",
                or: "salvad,san salvad,ulan bat,marib",
                us: "damasc,pirae,aarh,vilni",
                as: "carac,patr,burg,kaun",
                va: "craio,petah tik,gene,bratisla",
                ai: "shangh,mumb,chenn,chiang m",
                ne: "colog,melbour,brisba,lausan",
                er: "manchest,vancouv,tangi",
                ka: "dha,osa,banja lu",
                ro: "rio de janei,sappo,cai",
                am: "birmingh,amsterd,rotterd",
                ur: "kuala lump,winterth,kópavog",
                ch: "muni,züri,christchur",
                na: "barcelo,vien,var",
                ma: "yokoha,li,pana",
                ul: "istanb,seo,kab",
                to: "toron,qui,por",
                iv: "khark,lv,tel av",
                sk: "dnipropetrov,gdań,min"
            };
            cities = fns.expand_suffixes(cities, suffix_compressed_cities);
            var prefix_compressed_cities = {
                "new ": "delhi,york,taipei",
                san: "a'a,tiago, josé",
                ta: "ipei,mpere,llinn,rtu",
                ba: "ngalore,ngkok,ku,sel",
                li: "verpool,ège,nz,massol",
                ma: "rseille,ndalay,drid,lmö",
                be: "rn,lgrade,irut",
                ka: "rachi,raj,ndy",
                da: "egu,kar,ugavpils",
                ch: "icago,arleroi,ișinău",
                co: "lombo,nstanța,rk",
                bu: "rsa,charest,dapest"
            };
            cities = fns.expand_prefixes(cities, prefix_compressed_cities);
            var airports = [ "atl", "pek", "lhr", "hnd", "ord", "lax", "cdg", "dfw", "cgk", "dxb", "fra", "hkg", "den", "bkk", "ams", "jfk", "ist", "sfo", "clt", "las", "phx", "iax", "kul", "mia", "icn", "muc", "syd", "fco", "mco", "bcn", "yyz", "lgw", "phl" ];
            module.exports = {
                countries: countries,
                cities: cities,
                airports: airports
            };
        }, {
            "../fns": 23
        } ],
        20: [ function(require, module, exports) {
            "use strict";
            module.exports = [ "accountant", "advisor", "farmer", "mechanic", "technician", "architect", "clerk", "therapist", "bricklayer", "butcher", "carpenter", "nurse", "engineer", "supervisor", "attendant", "operator", "dietician", "housekeeper", "advisor", "agent", "firefighter", "fireman", "policeman", "attendant", "scientist", "gardener", "hairdresser", "instructor", "programmer", "administrator", "journalist", "assistant", "lawyer", "officer", "plumber", "inspector", "psychologist", "receptionist", "roofer", "sailor", "security guard", "photographer", "soldier", "surgeon", "researcher", "practitioner", "politician", "musician", "artist", "secretary", "minister", "deputy", "president" ];
        }, {} ],
        21: [ function(require, module, exports) {
            "use strict";
            module.exports = [ "aircraft", "bass", "bison", "fowl", "halibut", "moose", "salmon", "spacecraft", "tuna", "trout", "advice", "information", "knowledge", "trouble", "enjoyment", "fun", "recreation", "relaxation", "meat", "rice", "bread", "cake", "coffee", "ice", "water", "oil", "grass", "hair", "fruit", "wildlife", "equipment", "machinery", "furniture", "mail", "luggage", "jewelry", "clothing", "money", "mathematics", "economics", "physics", "civics", "ethics", "gymnastics", "mumps", "measles", "news", "tennis", "baggage", "currency", "soap", "toothpaste", "food", "sugar", "butter", "flour", "research", "leather", "wool", "wood", "coal", "weather", "homework", "cotton", "silk", "patience", "impatience", "vinegar", "art", "beef", "blood", "cash", "chaos", "cheese", "chewing", "conduct", "confusion", "education", "electricity", "entertainment", "fiction", "forgiveness", "gold", "gossip", "ground", "happiness", "history", "honey", "hospitality", "importance", "justice", "laughter", "leisure", "lightning", "literature", "luck", "melancholy", "milk", "mist", "music", "noise", "oxygen", "paper", "peace", "peanut", "pepper", "petrol", "plastic", "pork", "power", "pressure", "rain", "recognition", "sadness", "safety", "salt", "sand", "scenery", "shopping", "silver", "snow", "softness", "space", "speed", "steam", "sunshine", "tea", "thunder", "time", "traffic", "trousers", "violence", "warmth", "wine", "steel", "soccer", "hockey", "golf", "fish", "gum", "liquid", "series", "sheep", "species", "fahrenheit", "celcius", "kelvin", "hertz", "everyone", "everybody" ];
        }, {} ],
        22: [ function(require, module, exports) {
            "use strict";
            var fns = require("../fns");
            var compressed = {
                prove: "im,,ap,disap",
                serve: ",de,ob,re",
                ress: "exp,p,prog,st,add,d",
                lect: "ref,se,neg,col,e",
                sist: "in,con,per,re,as",
                tain: "ob,con,main,s,re",
                mble: "rese,gru,asse,stu",
                ture: "frac,lec,tor,fea",
                port: "re,sup,ex,im",
                ate: "rel,oper,indic,cre,h,activ,estim,particip,d,anticip,evalu",
                use: "ca,,over,ref,acc,am,pa,ho",
                ive: "l,rece,d,arr,str,surv,thr,rel",
                are: "prep,c,comp,sh,st,decl,d,sc",
                ine: "exam,imag,determ,comb,l,decl,underm,def",
                nce: "annou,da,experie,influe,bou,convi,enha",
                ain: "tr,rem,expl,dr,compl,g,str",
                ent: "prev,repres,r,res,rel,inv",
                age: "dam,mess,man,encour,eng,discour",
                rge: "su,cha,eme,u,me",
                ise: "ra,exerc,prom,surpr,pra",
                ect: "susp,dir,exp,def,rej",
                ter: "en,mat,cen,ca,al",
                end: "t,dep,,ext,att",
                est: "t,sugg,prot,requ,r",
                ock: "kn,l,sh,bl,unl",
                nge: "cha,excha,ra,challe,plu",
                ase: "incre,decre,purch,b,ce",
                ish: "establ,publ,w,fin,distingu",
                mit: "per,ad,sub,li",
                ure: "fig,ens,end,meas",
                der: "won,consi,mur,wan",
                ave: "s,sh,w,cr",
                ire: "requ,des,h,ret",
                tch: "scra,swi,ma,stre",
                ack: "att,l,p,cr",
                ion: "ment,quest,funct,envis",
                ump: "j,l,p,d",
                ide: "dec,prov,gu,s",
                ush: "br,cr,p,r",
                eat: "def,h,tr,ch",
                ash: "sm,spl,w,fl",
                rry: "ca,ma,hu,wo",
                ear: "app,f,b,disapp",
                er: "answ,rememb,off,suff,cov,discov,diff,gath,deliv,both,empow,with",
                le: "fi,sett,hand,sca,whist,enab,smi,ming,ru,sprink,pi",
                st: "exi,foreca,ho,po,twi,tru,li,adju,boa,contra,boo",
                it: "vis,ed,depos,sp,awa,inhib,cred,benef,prohib,inhab",
                nt: "wa,hu,pri,poi,cou,accou,confro,warra,pai",
                ch: "laun,rea,approa,sear,tou,ar,enri,atta",
                ss: "discu,gue,ki,pa,proce,cro,glo,dismi",
                ll: "fi,pu,ki,ca,ro,sme,reca,insta",
                rn: "tu,lea,conce,retu,bu,ea,wa,gove",
                ce: "redu,produ,divor,fa,noti,pla,for,repla",
                te: "contribu,uni,tas,vo,no,constitu,ci",
                rt: "sta,comfo,exe,depa,asse,reso,conve",
                ck: "su,pi,che,ki,tri,wre",
                ct: "intera,restri,predi,attra,depi,condu",
                ke: "sta,li,bra,overta,smo,disli",
                se: "collap,suppo,clo,rever,po,sen",
                nd: "mi,surrou,dema,remi,expa,comma",
                ve: "achie,invol,remo,lo,belie,mo",
                rm: "fo,perfo,confi,confo,ha",
                or: "lab,mirr,fav,monit,hon",
                ue: "arg,contin,val,iss,purs",
                ow: "all,foll,sn,fl,borr",
                ay: "pl,st,betr,displ,portr",
                ze: "recogni,reali,snee,ga,emphasi",
                ip: "cl,d,gr,sl,sk",
                re: "igno,sto,interfe,sco",
                ng: "spri,ba,belo,cli",
                ew: "scr,vi,revi,ch",
                gh: "cou,lau,outwei,wei",
                ly: "app,supp,re,multip",
                ge: "jud,acknowled,dod,alle",
                en: "list,happ,threat,strength",
                ee: "fors,agr,disagr,guarant",
                et: "budg,regr,mark,targ",
                rd: "rega,gua,rewa,affo",
                am: "dre,j,sl,ro",
                ry: "va,t,c,bu"
            };
            var arr = [ "hope", "thank", "work", "stop", "control", "join", "enjoy", "fail", "aid", "ask", "talk", "add", "walk", "describe", "study", "seem", "occur", "claim", "fix", "help", "design", "include", "need", "keep", "assume", "accept", "do", "look", "die", "seek", "attempt", "bomb", "cook", "copy", "claw", "doubt", "drift", "envy", "fold", "flood", "focus", "lift", "link", "load", "loan", "melt", "overlap", "rub", "repair", "sail", "sleep", "trade", "trap", "travel", "tune", "undergo", "undo", "uplift", "yawn", "plan", "reveal", "owe", "sneak", "drop", "name", "head", "spoil", "echo", "deny", "yield", "reason", "defy", "applaud", "risk", "step", "deem", "embody", "adopt", "convey", "pop", "grab", "revel", "stem", "mark", "drag", "pour", "reckon", "assign", "rank", "destroy", "float", "appeal", "grasp", "shout", "overcome", "relax", "excel", "plug", "proclaim", "ruin", "abandon", "overwhelm", "wipe", "added", "took", "goes", "avoid", "come", "set", "pay", "grow", "inspect", "instruct", "know", "take", "let", "sort", "put", "take", "cut", "become", "reply", "happen", "watch", "associate", "send", "archive", "cancel", "learn", "transfer" ];
            module.exports = fns.expand_suffixes(arr, compressed);
        }, {
            "../fns": 23
        } ],
        23: [ function(require, module, exports) {
            "use strict";
            exports.pluck = function(arr, str) {
                arr = arr || [];
                return arr.map(function(o) {
                    return o[str];
                });
            };
            exports.toObj = function(arr) {
                return arr.reduce(function(h, a) {
                    h[a] = true;
                    return h;
                }, {});
            };
            exports.reverseObj = function(obj) {
                return Object.keys(obj).reduce(function(h, k) {
                    h[obj[k]] = k;
                    return h;
                }, {});
            };
            exports.flatten = function(arr) {
                var all = [];
                arr.forEach(function(a) {
                    all = all.concat(a);
                });
                return all;
            };
            exports.endsWith = function(str, suffix) {
                if (str && suffix && str.indexOf(suffix, str.length - suffix.length) !== -1) {
                    return true;
                }
                return false;
            };
            exports.startsWith = function(str, prefix) {
                if (str && str.length && str.substr(0, 1) === prefix) {
                    return true;
                }
                return false;
            };
            exports.extend = function(a, b) {
                var keys = Object.keys(b);
                for (var i = 0; i < keys.length; i++) {
                    a[keys[i]] = b[keys[i]];
                }
                return a;
            };
            exports.titlecase = function(str) {
                if (!str) {
                    return "";
                }
                str = str.toLowerCase();
                return str.charAt(0).toUpperCase() + str.slice(1);
            };
            exports.isFunction = function(obj) {
                return Object.prototype.toString.call(obj) === "[object Function]";
            };
            exports.expand_suffixes = function(list, obj) {
                var keys = Object.keys(obj);
                var l = keys.length;
                for (var i = 0; i < l; i++) {
                    var arr = obj[keys[i]].split(",");
                    for (var i2 = 0; i2 < arr.length; i2++) {
                        list.push(arr[i2] + keys[i]);
                    }
                }
                return list;
            };
            exports.expand_prefixes = function(list, obj) {
                var keys = Object.keys(obj);
                var l = keys.length;
                for (var i = 0; i < l; i++) {
                    var arr = obj[keys[i]].split(",");
                    for (var i2 = 0; i2 < arr.length; i2++) {
                        list.push(keys[i] + arr[i2]);
                    }
                }
                return list;
            };
        }, {} ],
        24: [ function(require, module, exports) {
            "use strict";
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
            };
            var fns = require("./fns.js");
            var models = {
                Term: require("./term/term.js"),
                Text: require("./text/text.js"),
                Sentence: require("./sentence/sentence.js"),
                Statement: require("./sentence/statement/statement.js"),
                Question: require("./sentence/question/question.js"),
                Verb: require("./term/verb/verb.js"),
                Adjective: require("./term/adjective/adjective.js"),
                Adverb: require("./term/adverb/adverb.js"),
                Noun: require("./term/noun/noun.js"),
                Value: require("./term/noun/value/value.js"),
                Person: require("./term/noun/person/person.js"),
                Place: require("./term/noun/place/place.js"),
                Date: require("./term/noun/date/date.js"),
                Organization: require("./term/noun/organization/organization.js")
            };
            function NLP() {
                this.plugin = function(obj) {
                    obj = obj || {};
                    if (fns.isFunction(obj)) {
                        obj = obj.call(this, this);
                    }
                    Object.keys(obj).forEach(function(k) {
                        Object.keys(obj[k]).forEach(function(method) {
                            models[k].fn[method] = obj[k][method];
                        });
                    });
                };
                this.lexicon = function() {
                    return require("./lexicon.js");
                };
                this.term = function(s) {
                    return new models.Term(s);
                };
                this.noun = function(s) {
                    return new models.Noun(s);
                };
                this.verb = function(s) {
                    return new models.Verb(s);
                };
                this.adjective = function(s) {
                    return new models.Adjective(s);
                };
                this.adverb = function(s) {
                    return new models.Adverb(s);
                };
                this.value = function(s) {
                    return new models.Value(s);
                };
                this.person = function(s) {
                    return new models.Person(s);
                };
                this.place = function(s) {
                    return new models.Place(s);
                };
                this.date = function(s) {
                    return new models.Date(s);
                };
                this.organization = function(s) {
                    return new models.Organization(s);
                };
                this.text = function(s, options) {
                    return new models.Text(s, options);
                };
                this.sentence = function(s, options) {
                    return new models.Sentence(s, options);
                };
                this.statement = function(s) {
                    return new models.Statement(s);
                };
                this.question = function(s) {
                    return new models.Question(s);
                };
            }
            var nlp = new NLP();
            if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" || typeof DedicatedWorkerGlobalScope === "function") {
                self.nlp_compromise = nlp;
            }
            if (typeof module !== "undefined" && module.exports) {
                module.exports = nlp;
            }
            if (typeof define === "function" && define.amd) {
                define(nlp);
            }
        }, {
            "./fns.js": 23,
            "./lexicon.js": 25,
            "./sentence/question/question.js": 55,
            "./sentence/sentence.js": 58,
            "./sentence/statement/statement.js": 61,
            "./term/adjective/adjective.js": 62,
            "./term/adverb/adverb.js": 67,
            "./term/noun/date/date.js": 72,
            "./term/noun/noun.js": 78,
            "./term/noun/organization/organization.js": 80,
            "./term/noun/person/person.js": 84,
            "./term/noun/place/place.js": 86,
            "./term/noun/value/value.js": 96,
            "./term/term.js": 97,
            "./term/verb/verb.js": 107,
            "./text/text.js": 110
        } ],
        25: [ function(require, module, exports) {
            "use strict";
            var fns = require("./fns.js");
            var verb_conjugate = require("./term/verb/conjugate/conjugate.js");
            var verb_to_adjective = require("./term/verb/to_adjective.js");
            var to_comparative = require("./term/adjective/to_comparative.js");
            var to_superlative = require("./term/adjective/to_superlative.js");
            var to_adverb = require("./term/adjective/to_adverb.js");
            var grand_mapping = require("./sentence/pos/parts_of_speech.js").tag_mapping;
            var lexicon = {};
            var addObj = function addObj(obj) {
                var keys = Object.keys(obj);
                var l = keys.length;
                for (var i = 0; i < l; i++) {
                    lexicon[keys[i]] = obj[keys[i]];
                }
            };
            var addArr = function addArr(arr, tag) {
                var l = arr.length;
                for (var i = 0; i < l; i++) {
                    lexicon[arr[i]] = tag;
                }
            };
            var verbMap = {
                infinitive: "Infinitive",
                present: "PresentTense",
                past: "PastTense",
                gerund: "Gerund",
                actor: "Actor",
                future: "FutureTense",
                pluperfect: "PluperfectTense",
                perfect: "PerfectTense",
                PerfectTense: "PerfectTense",
                PluperfectTense: "PluperfectTense",
                FutureTense: "FutureTense",
                PastTense: "PastTense",
                PresentTense: "PresentTense"
            };
            var irregulars = require("./data/irregular_verbs.js");
            var verbs = require("./data/verbs.js").concat(Object.keys(irregulars));
            var _loop = function _loop(i) {
                var o = verb_conjugate(verbs[i]);
                Object.keys(o).forEach(function(k) {
                    if (k && o[k] && verbMap[k]) {
                        lexicon[o[k]] = verbMap[k];
                    }
                });
                lexicon[verb_to_adjective(verbs[i])] = "Adjective";
            };
            for (var i = 0; i < verbs.length; i++) {
                _loop(i);
            }
            var orgs = require("./data/organizations.js");
            addArr(orgs.organizations, "Noun");
            addArr(orgs.suffixes, "Noun");
            var places = require("./data/places.js");
            addArr(places.countries, "Place");
            addArr(places.cities, "Place");
            require("./data/adjectives.js").forEach(function(s) {
                lexicon[s] = "Adjective";
                lexicon[to_comparative(s)] = "Comparative";
                lexicon[to_superlative(s)] = "Superlative";
                lexicon[to_adverb(s)] = "Adverb";
            });
            Object.keys(require("./data/convertables.js")).forEach(function(s) {
                lexicon[s] = "Adjective";
                lexicon[to_comparative(s)] = "Comparative";
                lexicon[to_superlative(s)] = "Superlative";
                lexicon[to_adverb(s)] = "Adverb";
            });
            addArr(require("./data/abbreviations.js").abbreviations, "Abbreviation");
            addArr(require("./data/demonyms.js"), "Demonym");
            addArr(require("./data/currencies.js"), "Currency");
            addArr(require("./data/honourifics.js"), "Honourific");
            addArr(require("./data/uncountables.js"), "Noun");
            var dates = require("./data/dates.js");
            addArr(dates.days, "Date");
            addArr(dates.months, "Date");
            addArr(dates.durations, "Date");
            addArr(dates.relative, "Date");
            var nums = require("./data/numbers.js");
            var all_nums = Object.keys(nums).reduce(function(arr, k) {
                arr = arr.concat(Object.keys(nums[k]));
                return arr;
            }, []);
            addArr(all_nums, "Value");
            addArr(Object.keys(require("./data/firstnames.js")), "Person");
            var irregNouns = require("./data/irregular_nouns.js");
            addArr(fns.pluck(irregNouns, 0), "Noun");
            addArr(fns.pluck(irregNouns, 1), "Plural");
            addObj(require("./data/misc.js"));
            addObj(require("./data/multiples.js"));
            addObj(require("./data/phrasal_verbs.js"));
            Object.keys(require("./data/holidays.js")).forEach(function(k) {
                lexicon[k] = "Date";
            });
            addArr(require("./data/professions.js"), "Actor");
            delete lexicon[false];
            delete lexicon[true];
            delete lexicon[undefined];
            delete lexicon[null];
            delete lexicon[""];
            Object.keys(lexicon).forEach(function(k) {
                lexicon[k] = grand_mapping[lexicon[k]] || lexicon[k];
            });
            module.exports = lexicon;
        }, {
            "./data/abbreviations.js": 1,
            "./data/adjectives.js": 2,
            "./data/convertables.js": 3,
            "./data/currencies.js": 4,
            "./data/dates.js": 5,
            "./data/demonyms.js": 6,
            "./data/firstnames.js": 7,
            "./data/holidays.js": 8,
            "./data/honourifics.js": 9,
            "./data/irregular_nouns.js": 10,
            "./data/irregular_verbs.js": 11,
            "./data/misc.js": 12,
            "./data/multiples.js": 13,
            "./data/numbers.js": 16,
            "./data/organizations.js": 17,
            "./data/phrasal_verbs.js": 18,
            "./data/places.js": 19,
            "./data/professions.js": 20,
            "./data/uncountables.js": 21,
            "./data/verbs.js": 22,
            "./fns.js": 23,
            "./sentence/pos/parts_of_speech.js": 37,
            "./term/adjective/to_adverb.js": 63,
            "./term/adjective/to_comparative.js": 64,
            "./term/adjective/to_superlative.js": 66,
            "./term/verb/conjugate/conjugate.js": 98,
            "./term/verb/to_adjective.js": 106
        } ],
        26: [ function(require, module, exports) {
            "use strict";
            var Result = require("./result");
            var syntax_parse = require("./syntax_parse");
            var match_term = require("./match_term");
            var tryFromHere = function tryFromHere(terms, regs, options) {
                var result = [];
                var which_term = 0;
                for (var i = 0; i < regs.length; i++) {
                    var term = terms[which_term];
                    if (!term) {
                        return null;
                    }
                    if (match_term(term, regs[i], options)) {
                        if (regs[i].signals.trailing && terms[which_term + 1]) {
                            return null;
                        }
                        if (regs[i].signals.leading && which_term !== 0) {
                            return null;
                        }
                        result.push(terms[which_term]);
                        which_term += 1;
                        continue;
                    }
                    if (term.normal === "") {
                        result.push(terms[which_term]);
                        which_term += 1;
                        term = terms[which_term];
                    }
                    if (regs[i].signals.any_one) {
                        result.push(terms[which_term]);
                        which_term += 1;
                        continue;
                    }
                    if (regs[i].signals.optional) {
                        continue;
                    }
                    return null;
                }
                return result;
            };
            var findAll = function findAll(terms, regs, options) {
                var result = [];
                regs = syntax_parse(regs || "");
                if (regs[0].signals.leading) {
                    var match = tryFromHere(terms, regs, options) || [];
                    if (match) {
                        return [ new Result(match) ];
                    } else {
                        return null;
                    }
                }
                var len = terms.length;
                for (var i = 0; i < len; i++) {
                    var termSlice = terms.slice(i, terms.length);
                    var match = tryFromHere(termSlice, regs, options);
                    if (match) {
                        result.push(new Result(match));
                    }
                }
                if (result.length === 0) {
                    return null;
                }
                return result;
            };
            var replaceAll = function replaceAll(terms, regs, replacement, options) {
                var list = findAll(terms, regs, options);
                if (list) {
                    list.forEach(function(t) {
                        t.replace(replacement, options);
                    });
                }
            };
            module.exports = {
                findAll: findAll,
                replaceAll: replaceAll
            };
        }, {
            "./match_term": 27,
            "./result": 28,
            "./syntax_parse": 29
        } ],
        27: [ function(require, module, exports) {
            "use strict";
            var fns = require("../fns.js");
            var match_term = function match_term(term, reg) {
                if (!term || !reg || !reg.signals) {
                    return false;
                }
                var signals = reg.signals;
                if (signals.one_of) {
                    var arr = reg.term.split("|");
                    for (var i = 0; i < arr.length; i++) {
                        if (arr[i] === term.normal || arr[i] === term.text) {
                            return true;
                        }
                    }
                    return false;
                }
                if (signals.pos) {
                    var pos = fns.titlecase(reg.term);
                    if (term.pos[pos]) {
                        return true;
                    }
                    return false;
                }
                if (signals.alias) {
                    if (reg.term === term.root()) {
                        return true;
                    }
                    return false;
                }
                if (reg.term === term.normal || reg.term === term.text || reg.term === term.expansion) {
                    return true;
                }
                return false;
            };
            module.exports = match_term;
        }, {
            "../fns.js": 23
        } ],
        28: [ function(require, module, exports) {
            "use strict";
            var _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                };
            }();
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            }
            var _match = require("./match.js");
            var Result = function() {
                function Result(terms) {
                    _classCallCheck(this, Result);
                    this.terms = terms;
                }
                _createClass(Result, [ {
                    key: "match",
                    value: function match(str, options) {
                        return _match(this.terms, str, options);
                    }
                }, {
                    key: "replace",
                    value: function replace(words) {
                        for (var i = 0; i < this.terms.length; i++) {
                            if (words[i] === "$") {
                                continue;
                            }
                            if (words[i].match(/\$1/)) {
                                var combined = words[1].replace(/\$1/, this.terms[i].text);
                                this.terms[i].changeTo(combined);
                                continue;
                            }
                            this.terms[i].changeTo(words[i] || "");
                        }
                        return this;
                    }
                }, {
                    key: "text",
                    value: function text() {
                        return this.terms.reduce(function(s, t) {
                            if (t.text) {
                                s += " " + t.text;
                            }
                            return s;
                        }, "").trim();
                    }
                }, {
                    key: "normal",
                    value: function normal() {
                        return this.terms.reduce(function(s, t) {
                            if (t.normal) {
                                s += " " + t.normal;
                            }
                            return s;
                        }, "").trim();
                    }
                } ]);
                return Result;
            }();
            module.exports = Result;
        }, {
            "./match.js": 26
        } ],
        29: [ function(require, module, exports) {
            "use strict";
            var fns = require("../fns.js");
            var parse_term = function parse_term(term, i) {
                term = term || "";
                term = term.trim();
                var signals = {};
                if (fns.startsWith(term, "^")) {
                    term = term.substr(1, term.length);
                    signals.leading = true;
                }
                if (fns.endsWith(term, "$")) {
                    term = term.replace(/\$$/, "");
                    signals.trailing = true;
                }
                if (fns.endsWith(term, "?")) {
                    term = term.replace(/\?$/, "");
                    signals.optional = true;
                }
                if (fns.startsWith(term, "[") && fns.endsWith(term, "]")) {
                    term = term.replace(/\]$/, "");
                    term = term.replace(/^\[/, "");
                    signals.pos = true;
                }
                if (fns.startsWith(term, "(") && fns.endsWith(term, ")")) {
                    term = term.replace(/\)$/, "");
                    term = term.replace(/^\(/, "");
                    signals.one_of = true;
                }
                if (fns.startsWith(term, "~")) {
                    term = term.replace(/^\~/, "");
                    term = term.replace(/\~$/, "");
                    signals.alias = true;
                }
                if (fns.startsWith(term, "+")) {
                    term = term.replace(/^\+/, "");
                    term = term.replace(/\+$/, "");
                    signals.extra = true;
                }
                if (term === ".") {
                    signals.any_one = true;
                }
                if (term === "*") {
                    signals.any_many = true;
                }
                return {
                    term: term,
                    signals: signals,
                    i: i
                };
            };
            var parse_all = function parse_all(regs) {
                regs = regs || [];
                return regs.map(parse_term);
            };
            module.exports = parse_all;
        }, {
            "../fns.js": 23
        } ],
        30: [ function(require, module, exports) {
            "use strict";
            var pos = require("./pos/parts_of_speech.js");
            var flip_verb = function flip_verb(t, tense) {
                if (tense === "present") {
                    t.to_present();
                } else if (tense === "past") {
                    t.to_past();
                } else if (tense === "future") {
                    t.to_future();
                }
                return t;
            };
            var change_tense = function change_tense(s, tense) {
                for (var i = 0; i < s.terms.length; i++) {
                    var t = s.terms[i];
                    if (t instanceof pos.Verb) {
                        if (t.pos["Gerund"]) {
                            continue;
                        }
                        if (t.pos["Infinitive"]) {
                            if (s.terms[i - 1] && s.terms[i - 1].normal === "to") {
                                continue;
                            }
                        }
                        s.terms[i] = flip_verb(t, tense);
                    }
                }
                return s;
            };
            module.exports = change_tense;
        }, {
            "./pos/parts_of_speech.js": 37
        } ],
        31: [ function(require, module, exports) {
            "use strict";
            var contractor = {
                will: "ll",
                would: "d",
                have: "ve",
                are: "re",
                not: "t",
                is: "s"
            };
            var contract = function contract(terms) {
                for (var i = 1; i < terms.length; i++) {
                    if (contractor[terms[i].normal]) {
                        terms[i - 1].expansion = terms[i - 1].text;
                        terms[i].expansion = terms[i].text;
                        if (terms[i].normal === "not") {
                            terms[i - 1].text += "n";
                        }
                        terms[i - 1].text += "'" + contractor[terms[i].normal];
                        terms[i - 1].rebuild();
                        terms[i].text = "";
                        terms[i].rebuild();
                    }
                }
                return terms;
            };
            module.exports = contract;
        }, {} ],
        32: [ function(require, module, exports) {
            "use strict";
            var expand = function expand(terms) {
                for (var i = 0; i < terms.length; i++) {
                    if (terms[i].expansion) {
                        terms[i].text = terms[i].expansion;
                        terms[i].rebuild();
                    }
                }
                return terms;
            };
            module.exports = expand;
        }, {} ],
        33: [ function(require, module, exports) {
            "use strict";
            var passive_voice = function passive_voice(s) {
                var terms = s.terms;
                for (var i = 0; i < terms.length - 2; i++) {
                    if (terms[i].pos["Copula"] && terms[i + 1].pos["Verb"] && terms[i + 2].normal === "by") {
                        if (terms[i + 1].pos["Gerund"]) {
                            continue;
                        }
                        return true;
                    }
                }
                return false;
            };
            module.exports = passive_voice;
        }, {} ],
        34: [ function(require, module, exports) {
            "use strict";
            var pos = require("./parts_of_speech");
            var assign = function assign(t, tag, reason) {
                var P = pos.classMapping[tag] || pos.Term;
                var expansion = t.expansion;
                var whitespace = t.whitespace;
                t = new P(t.text, tag);
                t.reason = reason;
                t.whitespace = whitespace;
                t.expansion = expansion;
                return t;
            };
            module.exports = assign;
        }, {
            "./parts_of_speech": 37
        } ],
        35: [ function(require, module, exports) {
            "use strict";
            var pos = require("./parts_of_speech");
            var shouldLumpThree = function shouldLumpThree(a, b, c) {
                if (!a || !b || !c) {
                    return false;
                }
                var lump_rules = [ {
                    condition: a.pos.Noun && b.text === "&" && c.pos.Noun,
                    result: "Person"
                }, {
                    condition: a.pos.Noun && b.text === "N" && c.pos.Noun,
                    result: "Person"
                }, {
                    condition: a.pos.Date && b.normal === "the" && c.pos.Value,
                    result: "Date"
                }, {
                    condition: a.pos.Value && b.pos.Preposition && c.pos.Date,
                    result: "Date"
                }, {
                    condition: a.pos.Date && b.pos.Preposition && c.pos.Value,
                    result: "Date"
                }, {
                    condition: a.is_capital() && b.normal === "of" && c.is_capital(),
                    result: "Noun"
                }, {
                    condition: a.text.match(/^["']/) && !b.text.match(/["']/) && c.text.match(/["']$/),
                    result: "Noun"
                }, {
                    condition: a.normal === "will" && b.normal === "have" && b.pos.Verb,
                    result: "FutureTense"
                }, {
                    condition: a.pos.Date && (c.pos.Date || c.pos.Ordinal) && (b.pos.Preposition || b.pos.Determiner || b.pos.Conjunction || b.pos.Adjective),
                    result: "Date"
                }, {
                    condition: a.pos.Value && b.normal === "and" && c.pos.Value,
                    result: "Value"
                } ];
                for (var i = 0; i < lump_rules.length; i++) {
                    if (lump_rules[i].condition) {
                        return lump_rules[i].result;
                    }
                }
                return false;
            };
            var shouldLumpTwo = function shouldLumpTwo(a, b) {
                if (!a || !b) {
                    return false;
                }
                if (a.is_word() === false || b.is_word() === false) {
                    return false;
                }
                var lump_rules = [ {
                    condition: a.pos.Person && b.pos.Honourific || a.pos.Honourific && b.pos.Person,
                    result: "Person"
                }, {
                    condition: (a.pos.Value || a.pos.Date) && (b.normal === "am" || b.normal === "pm"),
                    result: "Date"
                }, {
                    condition: a.pos.Honourific && b.is_capital(),
                    result: "Person"
                }, {
                    condition: a.pos.Person && b.is_capital(),
                    result: "Person"
                }, {
                    condition: a.pos.Date && b.pos.Value,
                    result: "Date"
                }, {
                    condition: a.pos.Value && b.pos.Date,
                    result: "Date"
                }, {
                    condition: (a.normal === "last" || a.normal === "next" || a.normal === "this") && b.pos.Date,
                    result: "Date"
                }, {
                    condition: a.pos.Noun && b.pos.Actor,
                    result: "Actor"
                }, {
                    condition: a.pos.Value && b.pos.Noun && !a.pos.Ordinal,
                    result: "Value"
                }, {
                    condition: a.is_capital() && b.pos["Organization"] || b.is_capital() && a.pos["Organization"],
                    result: "Organization"
                }, {
                    condition: a.text.match(/^["']/) && b.text.match(/["']$/),
                    result: "Noun"
                }, {
                    condition: a.normal === "will" && b.pos.Verb,
                    result: "PerfectTense"
                }, {
                    condition: a.normal.match(/^will ha(ve|d)$/) && b.pos.Verb,
                    result: "PluperfectTense"
                }, {
                    condition: b.normal.match(/(standard|daylight|summer) time/) && (a.pos["Adjective"] || a.pos["Place"]),
                    result: "Date"
                }, {
                    condition: a.pos.Demonym && b.pos.Currency,
                    result: "Currency"
                } ];
                for (var i = 0; i < lump_rules.length; i++) {
                    if (lump_rules[i].condition) {
                        return lump_rules[i].result;
                    }
                }
                return false;
            };
            var fancy_lumping = function fancy_lumping(terms) {
                for (var i = 1; i < terms.length; i++) {
                    var a = terms[i - 1];
                    var b = terms[i];
                    var c = terms[i + 1];
                    var tag = shouldLumpTwo(a, b);
                    if (tag) {
                        var Cl = pos.classMapping[tag] || pos.Term;
                        var space = a.whitespace.trailing + b.whitespace.preceding;
                        terms[i] = new Cl(a.text + space + b.text, tag);
                        terms[i].reason = "lumpedtwo(" + terms[i].reason + ")";
                        terms[i].whitespace.preceding = a.whitespace.preceding;
                        terms[i].whitespace.trailing = b.whitespace.trailing;
                        terms[i - 1] = null;
                        continue;
                    }
                    if (c) {
                        tag = shouldLumpThree(a, b, c);
                        if (tag) {
                            var Cl = pos.classMapping[tag] || pos.Term;
                            var space1 = a.whitespace.trailing + b.whitespace.preceding;
                            var space2 = b.whitespace.trailing + c.whitespace.preceding;
                            var text = a.text + space1 + b.text + space2 + c.text;
                            terms[i - 1] = new Cl(text, tag);
                            terms[i - 1].reason = "lumpedThree(" + terms[i].reason + ")";
                            terms[i - 1].whitespace.preceding = a.whitespace.preceding;
                            terms[i - 1].whitespace.trailing = c.whitespace.trailing;
                            terms[i] = null;
                            terms[i + 1] = null;
                            continue;
                        }
                    }
                }
                terms = terms.filter(function(t) {
                    return t !== null;
                });
                return terms;
            };
            module.exports = fancy_lumping;
        }, {
            "./parts_of_speech": 37
        } ],
        36: [ function(require, module, exports) {
            "use strict";
            var friendlies = [ [ "Noun", "Abbreviation" ], [ "Abbreviation", "Noun" ] ];
            var should_chunk = function should_chunk(a, b) {
                if (!a || !b) {
                    return false;
                }
                if (a.has_comma() && !a.pos.Date) {
                    return false;
                }
                if (a.pos["Possessive"]) {
                    return false;
                }
                if (a.is_word() === false || b.is_word() === false) {
                    return false;
                }
                var dont_chunk = [ "Expression", "Phrasal" ];
                for (var i = 0; i < dont_chunk.length; i++) {
                    if (a.pos[dont_chunk[i]] || b.pos[dont_chunk[i]]) {
                        return false;
                    }
                }
                if (a.expansion || b.expansion) {
                    return false;
                }
                if (a.tag === b.tag) {
                    return true;
                }
                for (var i = 0; i < friendlies.length; i++) {
                    var f = friendlies[i];
                    if (a.pos[f[0]] && b.pos[f[1]]) {
                        return true;
                    }
                }
                return false;
            };
            var chunk_neighbours = function chunk_neighbours(terms) {
                var new_terms = [];
                var last_one = null;
                for (var i = 0; i < terms.length; i++) {
                    var t = terms[i];
                    if (should_chunk(last_one, t)) {
                        var space = last_one.whitespace.trailing + t.whitespace.preceding;
                        new_terms[new_terms.length - 1].text += space + t.text;
                        new_terms[new_terms.length - 1].normalize();
                        new_terms[new_terms.length - 1].whitespace.trailing = t.whitespace.trailing;
                        new_terms[new_terms.length - 1].whitespace.preceding = last_one.whitespace.preceding;
                    } else {
                        new_terms.push(t);
                    }
                    last_one = t;
                }
                return new_terms;
            };
            module.exports = chunk_neighbours;
        }, {} ],
        37: [ function(require, module, exports) {
            "use strict";
            var Term = require("../../term/term.js");
            var Verb = require("../../term/verb/verb.js");
            var Adverb = require("../../term/adverb/adverb.js");
            var Adjective = require("../../term/adjective/adjective.js");
            var Noun = require("../../term/noun/noun.js");
            var Person = require("../../term/noun/person/person.js");
            var Place = require("../../term/noun/place/place.js");
            var Organization = require("../../term/noun/organization/organization.js");
            var Value = require("../../term/noun/value/value.js");
            var _Date = require("../../term/noun/date/date.js");
            var tag_mapping = {
                NNA: "Acronym",
                NNS: "Plural",
                NN: "Noun",
                NNO: "Possessive",
                CD: "Value",
                AC: "Actor",
                DA: "Date",
                CO: "Condition",
                PN: "Person",
                PP: "Possessive",
                PRP: "Pronoun",
                EX: "Expression",
                DT: "Determiner",
                CC: "Conjunction",
                IN: "Preposition",
                VB: "Verb",
                VBD: "PastTense",
                VBF: "FutureTense",
                VBP: "Infinitive",
                VBZ: "PresentTense",
                VBG: "Gerund",
                VBN: "Verb",
                CP: "Copula",
                MD: "Modal",
                JJ: "Adjective",
                JJR: "Comparative",
                JJS: "Superlative",
                RB: "Adverb"
            };
            var classMapping = {
                Noun: Noun,
                Honourific: Noun,
                Acronym: Noun,
                Plural: Noun,
                Pronoun: Noun,
                Actor: Noun,
                Abbreviation: Noun,
                Currency: Noun,
                Verb: Verb,
                PresentTense: Verb,
                FutureTense: Verb,
                PastTense: Verb,
                Infinitive: Verb,
                PerfectTense: Verb,
                PluperfectTense: Verb,
                Gerund: Verb,
                Copula: Verb,
                Modal: Verb,
                Comparative: Adjective,
                Superlative: Adjective,
                Adjective: Adjective,
                Demonym: Adjective,
                Determiner: Term,
                Preposition: Term,
                Expression: Term,
                Conjunction: Term,
                Possessive: Term,
                Adverb: Adverb,
                Value: Value,
                Place: Place,
                Person: Person,
                Organization: Organization,
                Date: _Date
            };
            module.exports = {
                tag_mapping: tag_mapping,
                classMapping: classMapping,
                Term: Term,
                Date: _Date,
                Value: Value,
                Verb: Verb,
                Person: Person,
                Place: Place,
                Organization: Organization,
                Adjective: Adjective,
                Adverb: Adverb,
                Noun: Noun
            };
        }, {
            "../../term/adjective/adjective.js": 62,
            "../../term/adverb/adverb.js": 67,
            "../../term/noun/date/date.js": 72,
            "../../term/noun/noun.js": 78,
            "../../term/noun/organization/organization.js": 80,
            "../../term/noun/person/person.js": 84,
            "../../term/noun/place/place.js": 86,
            "../../term/noun/value/value.js": 96,
            "../../term/term.js": 97,
            "../../term/verb/verb.js": 107
        } ],
        38: [ function(require, module, exports) {
            "use strict";
            var assign = require("../assign");
            var tough_dates = {
                may: true,
                april: true,
                march: true,
                june: true,
                jan: true
            };
            var maybe_year = function maybe_year(t) {
                if (t.pos.Value) {
                    var num = t.number || 0;
                    if (num >= 1900 && num < 2030) {
                        return true;
                    }
                }
                return false;
            };
            var date_signals = {
                between: true,
                before: true,
                after: true,
                during: true,
                from: true,
                to: true,
                "in": true,
                of: true,
                the: true,
                next: true
            };
            var ambiguous_dates = function ambiguous_dates(terms) {
                for (var i = 0; i < terms.length; i++) {
                    var t = terms[i];
                    if (tough_dates[t.normal] || maybe_year(t)) {
                        if (terms[i + 1] && (terms[i + 1].pos["Value"] || terms[i + 1].pos["Date"])) {
                            terms[i] = assign(t, "Date", "date_signal");
                            continue;
                        }
                        if (terms[i - 1] && (terms[i - 1].pos["Value"] || terms[i - 1].pos["Date"])) {
                            terms[i] = assign(t, "Date", "date_signal");
                            continue;
                        }
                        if (terms[i + 1] && date_signals[terms[i + 1].normal]) {
                            terms[i] = assign(t, "Date", "date_signal");
                            continue;
                        }
                        if (terms[i - 1] && date_signals[terms[i - 1].normal]) {
                            terms[i] = assign(t, "Date", "date_signal");
                            continue;
                        }
                    }
                }
                return terms;
            };
            module.exports = ambiguous_dates;
        }, {
            "../assign": 34
        } ],
        39: [ function(require, module, exports) {
            "use strict";
            var assign = require("../assign");
            var capital_signals = function capital_signals(terms) {
                if (terms[0] && terms[0].is_acronym()) {
                    terms[0] = assign(terms[0], "Noun", "acronym");
                }
                for (var i = 1; i < terms.length; i++) {
                    if (terms[i].is_capital() || terms[i].is_acronym()) {
                        terms[i] = assign(terms[i], "Noun", "capital_signal");
                    }
                }
                return terms;
            };
            module.exports = capital_signals;
        }, {
            "../assign": 34
        } ],
        40: [ function(require, module, exports) {
            "use strict";
            var starts = {
                "if": true,
                "in the event": true,
                "in order to": true,
                "so long as": true,
                provided: true,
                "save that": true,
                after: true,
                once: true,
                "subject to": true,
                without: true,
                effective: true,
                upon: true,
                during: true,
                unless: true,
                according: true,
                notwithstanding: true,
                when: true,
                before: true
            };
            var verbSoon = function verbSoon(terms, x) {
                for (var i = 0; i < 5; i++) {
                    if (terms[i + x] && terms[i + x].pos["Verb"]) {
                        return true;
                    }
                }
                return false;
            };
            var nextComma = function nextComma(terms, i) {
                var max = terms.length - 1;
                if (max > i + 7) {
                    max = i + 7;
                }
                for (var x = i; x < max; x++) {
                    if (terms[x].has_comma() && verbSoon(terms, x)) {
                        return x;
                    }
                }
                if (i > 5 && terms.length - i < 5) {
                    return terms.length;
                }
                return null;
            };
            var tagCondition = function tagCondition(terms, start, stop) {
                for (var i = start; i <= stop; i++) {
                    if (!terms[i]) {
                        break;
                    }
                    terms[i].pos["Condition"] = true;
                }
            };
            var conditional_pass = function conditional_pass(terms) {
                if (terms[0] && starts[terms[0].normal]) {
                    var until = nextComma(terms, 0);
                    if (until) {
                        tagCondition(terms, 0, until);
                    }
                }
                for (var i = 3; i < terms.length; i++) {
                    if (starts[terms[i].normal] && terms[i - 1].has_comma()) {
                        var until = nextComma(terms, i);
                        if (until) {
                            tagCondition(terms, i, until);
                            i += until;
                        }
                    }
                }
                return terms;
            };
            module.exports = conditional_pass;
        }, {} ],
        41: [ function(require, module, exports) {
            "use strict";
            var pos = require("../../parts_of_speech");
            var supported = {
                ll: "will",
                d: "would",
                ve: "have",
                re: "are",
                m: "am"
            };
            var irregulars = {
                dunno: [ "do not", "know" ],
                wanna: [ "want", "to" ],
                gonna: [ "going", "to" ],
                im: [ "i", "am" ],
                alot: [ "a", "lot" ],
                dont: [ "do not" ],
                "don't": [ "do not" ],
                dun: [ "do not" ],
                "won't": [ "will not" ],
                wont: [ "will not" ],
                "can't": [ "can not" ],
                cannot: [ "can not" ],
                aint: [ "is not" ],
                "ain't": [ "is not" ],
                "shan't": [ "should not" ],
                "where'd": [ "where", "did" ],
                "when'd": [ "when", "did" ],
                "how'd": [ "how", "did" ],
                "what'd": [ "what", "did" ],
                brb: [ "be", "right", "back" ],
                "let's": [ "let", "us" ]
            };
            var handle_negate = function handle_negate(terms, i) {
                terms[i].expansion = terms[i].text.replace(/n'.*/, "");
                terms[i].expansion += " not";
                return terms;
            };
            var handle_simple = function handle_simple(terms, i, particle) {
                terms[i].expansion = terms[i].text.replace(/'.*/, "");
                var second_word = new pos.Verb("");
                second_word.expansion = particle;
                second_word.whitespace.trailing = terms[i].whitespace.trailing;
                terms[i].whitespace.trailing = " ";
                terms.splice(i + 1, 0, second_word);
                return terms;
            };
            var handle_irregulars = function handle_irregulars(terms, x, arr) {
                terms[x].expansion = arr[0];
                for (var i = 1; i < arr.length; i++) {
                    var t = new pos.Term("");
                    t.whitespace.trailing = terms[x].whitespace.trailing;
                    terms[x].whitespace.trailing = " ";
                    t.expansion = arr[i];
                    terms.splice(x + i, 0, t);
                }
                return terms;
            };
            var handle_copula = function handle_copula(terms, i) {
                terms[i].expansion = terms[i].text.replace(/'s$/, "");
                var second_word = new pos.Verb("");
                second_word.whitespace.trailing = terms[i].whitespace.trailing;
                terms[i].whitespace.trailing = " ";
                second_word.expansion = "is";
                terms.splice(i + 1, 0, second_word);
                return terms;
            };
            var interpret = function interpret(terms) {
                for (var i = 0; i < terms.length; i++) {
                    if (irregulars[terms[i].normal]) {
                        terms = handle_irregulars(terms, i, irregulars[terms[i].normal]);
                        continue;
                    }
                    if (terms[i].has_abbreviation()) {
                        var split = terms[i].normal.split(/'/);
                        var pre = split[0];
                        var post = split[1];
                        if (supported[post]) {
                            terms = handle_simple(terms, i, supported[post]);
                            continue;
                        }
                        if (post === "t" && pre.match(/n$/)) {
                            terms = handle_negate(terms, i);
                            continue;
                        }
                        if (post === "s" && terms[i].pos["Possessive"]) {
                            continue;
                        }
                        if (post === "s") {
                            terms = handle_copula(terms, i);
                            continue;
                        }
                    }
                }
                return terms;
            };
            module.exports = interpret;
        }, {
            "../../parts_of_speech": 37
        } ],
        42: [ function(require, module, exports) {
            "use strict";
            var assign = require("../assign");
            var grammar_rules = require("./rules/grammar_rules");
            var fns = require("../../../fns");
            var hasTags = function hasTags(terms, tags) {
                if (terms.length !== tags.length) {
                    return false;
                }
                for (var i = 0; i < tags.length; i++) {
                    if (fns.startsWith(tags[i], "[") && fns.endsWith(tags[i], "]")) {
                        var pos = tags[i].match(/^\[(.*?)\]$/)[1];
                        if (!terms[i].pos[pos]) {
                            return false;
                        }
                    } else if (terms[i].normal !== tags[i]) {
                        return false;
                    }
                }
                return true;
            };
            var grammar_rules_pass = function grammar_rules_pass(s) {
                for (var i = 0; i < s.terms.length; i++) {
                    for (var o = 0; o < grammar_rules.length; o++) {
                        var rule = grammar_rules[o];
                        var terms = s.terms.slice(i, i + rule.before.length);
                        if (hasTags(terms, rule.before)) {
                            for (var c = 0; c < rule.before.length; c++) {
                                if (rule.after[c]) {
                                    var newPos = rule.after[c].match(/^\[(.*?)\]$/)[1];
                                    s.terms[i + c] = assign(s.terms[i + c], newPos, "grammar_rule  (" + rule.before.join(",") + ")");
                                }
                            }
                            break;
                        }
                    }
                }
                return s.terms;
            };
            module.exports = grammar_rules_pass;
        }, {
            "../../../fns": 23,
            "../assign": 34,
            "./rules/grammar_rules": 50
        } ],
        43: [ function(require, module, exports) {
            "use strict";
            var assign = require("../assign");
            var interjection_fixes = function interjection_fixes(terms) {
                var interjections = {
                    ok: true,
                    so: true,
                    please: true,
                    alright: true,
                    well: true,
                    now: true
                };
                for (var i = 0; i < terms.length; i++) {
                    if (i > 3) {
                        break;
                    }
                    if (interjections[terms[i].normal]) {
                        terms[i] = assign(terms[i], "Expression", "interjection_fixes");
                    } else {
                        break;
                    }
                }
                return terms;
            };
            module.exports = interjection_fixes;
        }, {
            "../assign": 34
        } ],
        44: [ function(require, module, exports) {
            "use strict";
            var defaultLexicon = require("../../../lexicon.js");
            var assign = require("../assign");
            var lexicon_pass = function lexicon_pass(terms, options) {
                var lexicon = options.lexicon || defaultLexicon;
                return terms.map(function(t) {
                    var normal = t.normal;
                    if (t.has_abbreviation()) {
                        var split = normal.split(/'/);
                        if (split[1] === "s") {
                            normal = split[0];
                        }
                    }
                    if (lexicon[normal] !== undefined) {
                        return assign(t, lexicon[normal], "lexicon_pass");
                    }
                    if (lexicon[t.expansion] !== undefined) {
                        return assign(t, lexicon[t.expansion], "lexicon_expansion");
                    }
                    if (normal.match(/^(over|under|out|-|un|re|en).{3}/)) {
                        var attempt = normal.replace(/^(over|under|out|.*?-|un|re|en)/, "");
                        return assign(t, lexicon[attempt], "lexicon_prefix");
                    }
                    if (t.has_abbreviation()) {
                        var attempt = normal.replace(/'(ll|re|ve|re|d|m)/, "");
                        return assign(t, lexicon[attempt], "lexicon_prefix");
                    }
                    if (normal.match(/-/)) {
                        var sides = normal.split("-");
                        if (lexicon[sides[0]]) {
                            return assign(t, lexicon[sides[0]], "lexicon_dash");
                        }
                        if (lexicon[sides[1]]) {
                            return assign(t, lexicon[sides[1]], "lexicon_dash");
                        }
                    }
                    return t;
                });
            };
            module.exports = lexicon_pass;
        }, {
            "../../../lexicon.js": 25,
            "../assign": 34
        } ],
        45: [ function(require, module, exports) {
            "use strict";
            var lexicon = require("../../../lexicon.js");
            var assign = require("../assign");
            var should_merge = function should_merge(a, b) {
                if (!a || !b) {
                    return false;
                }
                if (lexicon[a.normal + " " + b.normal]) {
                    return true;
                }
                return false;
            };
            var multiples_pass = function multiples_pass(terms) {
                var new_terms = [];
                var last_one = null;
                for (var i = 0; i < terms.length; i++) {
                    var t = terms[i];
                    if (should_merge(last_one, t)) {
                        var last = new_terms[new_terms.length - 1];
                        var space = t.whitespace.preceding + last.whitespace.trailing;
                        last.text += space + t.text;
                        last.rebuild();
                        last.whitespace.trailing = t.whitespace.trailing;
                        var pos = lexicon[last.normal];
                        new_terms[new_terms.length - 1] = assign(last, pos, "multiples_pass_lexicon");
                        new_terms[new_terms.length - 1].whitespace = last.whitespace;
                    } else {
                        new_terms.push(t);
                    }
                    last_one = t;
                }
                return new_terms;
            };
            module.exports = multiples_pass;
        }, {
            "../../../lexicon.js": 25,
            "../assign": 34
        } ],
        46: [ function(require, module, exports) {
            "use strict";
            var phrasals = require("../../../data/phrasal_verbs");
            var phrasal_verbs = function phrasal_verbs(terms) {
                for (var i = 0; i < terms.length - 1; i++) {
                    if (!terms[i] || !terms[i + 1]) {
                        break;
                    }
                    if (terms[i].pos["Verb"] && phrasals[terms[i].normal + terms[i + 1].normal]) {
                        if (terms[i].pos["Copula"]) {
                            continue;
                        }
                        terms[i].pos["Phrasal"] = true;
                        terms[i].text = terms[i].text + " " + terms[i + 1].text;
                        terms[i].reason = "phrasal(" + terms[i].reason + ")";
                        terms[i + 1] = null;
                        terms[i].rebuild();
                    }
                }
                terms = terms.filter(function(t) {
                    return t !== null;
                });
                return terms;
            };
            module.exports = phrasal_verbs;
        }, {
            "../../../data/phrasal_verbs": 18
        } ],
        47: [ function(require, module, exports) {
            "use strict";
            var assign = require("../assign");
            var blacklist = {
                "it's": true,
                "that's": true
            };
            var is_possessive = function is_possessive(terms, x) {
                if (blacklist[terms[x].normal]) {
                    return false;
                }
                if (terms[x].normal.match(/[a-z]s'$/)) {
                    return true;
                }
                if (!terms[x].normal.match(/[a-z]'s$/)) {
                    return false;
                }
                if (terms[x].pos["Pronoun"]) {
                    return false;
                }
                var nextWord = terms[x + 1];
                if (!nextWord) {
                    return true;
                }
                if (nextWord.pos["Noun"]) {
                    return true;
                }
                if (nextWord.pos["Adjective"] && terms[x + 2] && terms[x + 2].pos["Noun"]) {
                    return true;
                }
                if (nextWord.pos["Adjective"] || nextWord.pos["Verb"] || nextWord.pos["Adverb"]) {
                    return false;
                }
                return false;
            };
            var possessive_pass = function possessive_pass(terms) {
                for (var i = 0; i < terms.length; i++) {
                    if (is_possessive(terms, i)) {
                        if (!terms[i].pos["Noun"]) {
                            terms[i] = assign(terms[i], "Noun", "possessive_pass");
                        }
                        terms[i].pos["Possessive"] = true;
                    }
                }
                return terms;
            };
            module.exports = possessive_pass;
        }, {
            "../assign": 34
        } ],
        48: [ function(require, module, exports) {
            "use strict";
            var startQuote = function startQuote(s) {
                return s.match(/^["\u201C]./);
            };
            var endQuote = function endQuote(s) {
                return s.match(/.["\u201D]$/);
            };
            var quotation_ending = function quotation_ending(terms, start) {
                for (var i = start; i < terms.length; i++) {
                    if (endQuote(terms[i].text)) {
                        return i;
                    }
                }
                return null;
            };
            var tagQuotation = function tagQuotation(terms, start, stop) {
                for (var i = start; i <= stop; i++) {
                    if (!terms[i]) {
                        break;
                    }
                    terms[i].pos["Quotation"] = true;
                }
            };
            var quotation_pass = function quotation_pass(terms) {
                for (var i = 0; i < terms.length; i++) {
                    if (startQuote(terms[i].text)) {
                        var end = quotation_ending(terms, [ i ]);
                        if (end !== null) {
                            tagQuotation(terms, i, end);
                            return terms;
                        }
                    }
                }
                return terms;
            };
            module.exports = quotation_pass;
        }, {} ],
        49: [ function(require, module, exports) {
            "use strict";
            var word_rules = require("./rules/word_rules");
            var assign = require("../assign");
            var punct_rules = [ {
                reg: new RegExp("^[12]?[0-9]:[0-9]{2}( am| pm)?$", "i"),
                pos: "Date"
            }, {
                reg: new RegExp("^[0-9]{1,4}[-/][0-9]{1,2}[-/][0-9]{1,4}$", "i"),
                pos: "Date"
            }, {
                reg: new RegExp("^[0-9]{1,2}:[0-9]{2}(:[0-9]{2})?", "i"),
                pos: "Date"
            } ];
            var regex_pass = function regex_pass(terms) {
                terms.forEach(function(t, i) {
                    if (terms[i].tag !== "?") {
                        return;
                    }
                    var text = terms[i].text;
                    var normal = terms[i].normal;
                    if (terms[i].has_abbreviation()) {
                        var split = terms[i].normal.split(/'/);
                        if (split[1] === "s") {
                            normal = split[0];
                        }
                    }
                    for (var o = 0; o < punct_rules.length; o++) {
                        if (text.match(punct_rules[o].reg)) {
                            terms[i] = assign(terms[i], punct_rules[o].pos, "rules_pass_" + o);
                            return;
                        }
                    }
                    for (var o = 0; o < word_rules.length; o++) {
                        if (normal.match(word_rules[o].reg)) {
                            terms[i] = assign(terms[i], word_rules[o].pos, "rules_pass_" + o);
                            return;
                        }
                    }
                });
                return terms;
            };
            module.exports = regex_pass;
        }, {
            "../assign": 34,
            "./rules/word_rules": 51
        } ],
        50: [ function(require, module, exports) {
            "use strict";
            module.exports = [ {
                before: [ "[Determiner]", "[?]" ],
                after: [ "[Determiner]", "[Noun]" ]
            }, {
                before: [ "the", "[Verb]" ],
                after: [ null, "[Noun]" ]
            }, {
                before: [ "[Determiner]", "[Adjective]", "[Verb]" ],
                after: [ "[Noun]", "[Noun]", "[Noun]" ]
            }, {
                before: [ "[Determiner]", "[Adverb]", "[Adjective]", "[?]" ],
                after: [ "[Determiner]", "[Adverb]", "[Adjective]", "[Noun]" ]
            }, {
                before: [ "[?]", "[Determiner]", "[Noun]" ],
                after: [ "[Verb]", "[Determiner]", "[Noun]" ]
            }, {
                before: [ "[Person]", "the", "[Noun]" ],
                after: [ "[Person]", null, "[Noun]" ]
            }, {
                before: [ "[Noun]", "the", "[Noun]" ],
                after: [ "[Verb]", null, "[Noun]" ]
            }, {
                before: [ "[Possessive]", "[?]" ],
                after: [ "[Possessive]", "[Noun]" ]
            }, {
                before: [ "[?]", "[Possessive]", "[Noun]" ],
                after: [ "[Verb]", "[Possessive]", "[Noun]" ]
            }, {
                before: [ "[Copula]", "[?]" ],
                after: [ "[Copula]", "[Adjective]" ]
            }, {
                before: [ "[Copula]", "[Adverb]", "[?]" ],
                after: [ "[Copula]", "[Adverb]", "[Adjective]" ]
            }, {
                before: [ "[?]", "[Preposition]" ],
                after: [ "[Verb]", "[Preposition]" ]
            }, {
                before: [ "[Adverb]", "[Conjunction]", "[Adverb]" ],
                after: [ "[Adverb]", "[Adverb]", "[Adverb]" ]
            }, {
                before: [ "[Verb]", "not" ],
                after: [ "[Verb]", "[Verb]" ]
            }, {
                before: [ "[Adjective]", "[Conjunction]", "[Adjective]" ],
                after: [ "[Adjective]", "[Adjective]", "[Adjective]" ]
            }, {
                before: [ "[?]", "[Conjunction]", "[Verb]" ],
                after: [ "[Verb]", "[Conjunction]", "[Verb]" ]
            }, {
                before: [ "[Verb]", "[Conjunction]", "[?]" ],
                after: [ "[Verb]", "[Conjunction]", "[Verb]" ]
            }, {
                before: [ "[Noun]", "[Adverb]", "[Noun]" ],
                after: [ "[Noun]", "[Adverb]", "[Verb]" ]
            }, {
                before: [ "[?]", "[Pronoun]" ],
                after: [ "[Verb]", "[Pronoun]" ]
            }, {
                before: [ "[Modal]", "[?]" ],
                after: [ "[Modal]", "[Verb]" ]
            }, {
                before: [ "[Modal]", "[Adverb]", "[?]" ],
                after: [ "[Modal]", "[Adverb]", "[Verb]" ]
            }, {
                before: [ "[Adverb]", "[Value]" ],
                after: [ "[Adverb]", "[Verb]" ]
            } ];
        }, {} ],
        51: [ function(require, module, exports) {
            "use strict";
            var tag_mapping = require("../../parts_of_speech.js").tag_mapping;
            module.exports = [ [ "^[0-9]+ ?(am|pm)$", "DA" ], [ "^[0-9]+(st|nd|rd)?$", "CD" ], [ "^[a-z]et$", "VB" ], [ "cede$", "VB" ], [ ".[cts]hy$", "JJ" ], [ ".[st]ty$", "JJ" ], [ ".[lnr]ize$", "VB" ], [ ".[gk]y$", "JJ" ], [ ".fies$", "VB" ], [ ".some$", "JJ" ], [ ".[nrtumcd]al$", "JJ" ], [ ".que$", "JJ" ], [ ".[tnl]ary$", "JJ" ], [ ".[di]est$", "JJS" ], [ "^(un|de|re)\\-[a-z]..", "VB" ], [ ".lar$", "JJ" ], [ "[bszmp]{2}y", "JJ" ], [ ".zes$", "VB" ], [ ".[icldtgrv]ent$", "JJ" ], [ ".[rln]ates$", "VBZ" ], [ ".[oe]ry$", "JJ" ], [ "[rdntkdhs]ly$", "RB" ], [ ".[lsrnpb]ian$", "JJ" ], [ ".[^aeiou]ial$", "JJ" ], [ ".[^aeiou]eal$", "JJ" ], [ ".[vrl]id$", "JJ" ], [ ".[ilk]er$", "JJR" ], [ ".ike$", "JJ" ], [ ".ends?$", "VB" ], [ ".wards$", "RB" ], [ ".rmy$", "JJ" ], [ ".rol$", "NN" ], [ ".tors$", "NN" ], [ ".azy$", "JJ" ], [ ".where$", "RB" ], [ ".ify$", "VB" ], [ ".bound$", "JJ" ], [ ".[^z]ens$", "VB" ], [ ".oid$", "JJ" ], [ ".vice$", "NN" ], [ ".rough$", "JJ" ], [ ".mum$", "JJ" ], [ ".teen(th)?$", "CD" ], [ ".oses$", "VB" ], [ ".ishes$", "VB" ], [ ".ects$", "VB" ], [ ".tieth$", "CD" ], [ ".ices$", "NN" ], [ ".pose$", "VB" ], [ ".ions$", "NN" ], [ ".ean$", "JJ" ], [ ".[ia]sed$", "JJ" ], [ ".tized$", "VB" ], [ ".llen$", "JJ" ], [ ".fore$", "RB" ], [ ".ances$", "NN" ], [ ".gate$", "VB" ], [ ".nes$", "VB" ], [ ".less$", "RB" ], [ ".ried$", "JJ" ], [ ".gone$", "JJ" ], [ ".made$", "JJ" ], [ ".[pdltrkvyns]ing$", "JJ" ], [ ".tions$", "NN" ], [ ".tures$", "NN" ], [ ".ous$", "JJ" ], [ ".ports$", "NN" ], [ ". so$", "RB" ], [ ".ints$", "NN" ], [ ".[gt]led$", "JJ" ], [ ".lked$", "VB" ], [ ".fully$", "RB" ], [ ".*ould$", "MD" ], [ "^-?[0-9]+(.[0-9]+)?$", "CD" ], [ "[a-z]*\\-[a-z]*\\-", "JJ" ], [ "[a-z]'s$", "NNO" ], [ ".'n$", "VB" ], [ ".'re$", "CP" ], [ ".'ll$", "MD" ], [ ".'t$", "VB" ], [ ".tches$", "VB" ], [ "^https?:?//[a-z0-9]", "NN" ], [ "^www.[a-z0-9]", "NN" ], [ ".ize$", "VB" ], [ ".[^aeiou]ise$", "VB" ], [ ".[aeiou]te$", "VB" ], [ ".ea$", "NN" ], [ "[aeiou][pns]er$", "NN" ], [ ".ia$", "NN" ], [ ".sis$", "NN" ], [ ".[aeiou]na$", "NN" ], [ ".[^aeiou]ity$", "NN" ], [ ".[^aeiou]ium$", "NN" ], [ ".[^aeiou][ei]al$", "JJ" ], [ ".ffy$", "JJ" ], [ ".[^aeiou]ic$", "JJ" ], [ ".(gg|bb|zz)ly$", "JJ" ], [ ".[aeiou]my$", "JJ" ], [ ".[^aeiou][ai]ble$", "JJ" ], [ ".[^aeiou]eable$", "JJ" ], [ ".[^aeiou]ful$", "JJ" ], [ ".[^aeiou]ish$", "JJ" ], [ ".[^aeiou]ica$", "NN" ], [ "[aeiou][^aeiou]is$", "NN" ], [ "[^aeiou]ard$", "NN" ], [ "[^aeiou]ism$", "NN" ], [ ".[^aeiou]ity$", "NN" ], [ ".[^aeiou]ium$", "NN" ], [ ".[lstrn]us$", "NN" ], [ "..ic$", "JJ" ], [ "[aeiou][^aeiou]id$", "JJ" ], [ ".[^aeiou]ish$", "JJ" ], [ ".[^aeiou]ive$", "JJ" ], [ "[ea]{2}zy$", "JJ" ], [ "[^aeiou]ician$", "AC" ], [ ".keeper$", "AC" ], [ ".logist$", "AC" ], [ "..ier$", "AC" ], [ ".[^aeiou][ao]pher$", "AC" ], [ ".tive$", "AC" ], [ "[aeiou].*ist$", "JJ" ], [ "[^i]fer$", "VB" ], [ "^um+$", "EX" ], [ "^([hyj]a)+$", "EX" ], [ "^(k)+$", "EX" ], [ "^(yo)+$", "EX" ], [ "^yes+$", "EX" ], [ "^no+$", "EX" ], [ "^lol[sz]$", "EX" ], [ "^woo+[pt]?$", "EX" ], [ "^ug?h+$", "EX" ], [ "^uh[ -]?oh$", "EX" ] ].map(function(a) {
                return {
                    reg: new RegExp(a[0], "i"),
                    pos: tag_mapping[a[1]]
                };
            });
        }, {
            "../../parts_of_speech.js": 37
        } ],
        52: [ function(require, module, exports) {
            "use strict";
            var lumper = require("./lumper");
            var fancy_lumping = require("./fancy_lumping");
            var pos = require("./parts_of_speech");
            var assign = require("./assign");
            var grammar_pass = require("./passes/grammar_pass");
            var phrasal_verbs = require("./passes/phrasal_verbs");
            var interjection_fixes = require("./passes/interjection_fixes");
            var lexicon_pass = require("./passes/lexicon_pass");
            var capital_signals = require("./passes/capital_signals");
            var conditional_pass = require("./passes/conditional_pass");
            var ambiguous_dates = require("./passes/ambiguous_dates");
            var multiple_pass = require("./passes/multiples_pass");
            var regex_pass = require("./passes/regex_pass");
            var quotation_pass = require("./passes/quotation_pass");
            var possessive_pass = require("./passes/possessive_pass");
            var contraction_pass = require("./passes/contractions/interpret");
            var noun_fallback = function noun_fallback(terms) {
                for (var i = 0; i < terms.length; i++) {
                    if (terms[i].tag === "?" && terms[i].normal.match(/[a-z]/)) {
                        terms[i] = assign(terms[i], "Noun", "fallback");
                    }
                }
                return terms;
            };
            var specific_noun = function specific_noun(terms) {
                for (var i = 0; i < terms.length; i++) {
                    var t = terms[i];
                    if (t instanceof pos.Noun) {
                        if (t.is_person()) {
                            terms[i] = assign(t, "Person", "is_person");
                        } else if (t.is_place()) {
                            terms[i] = assign(t, "Place", "is_place");
                        } else if (t.is_value()) {
                            terms[i] = assign(t, "Value", "is_value");
                        } else if (t.is_date()) {
                            terms[i] = assign(t, "Date", "is_date");
                        } else if (t.is_organization()) {
                            terms[i] = assign(t, "Organization", "is_organization");
                        }
                    }
                }
                return terms;
            };
            var tagger = function tagger(s, options) {
                s.terms = capital_signals(s.terms);
                s.terms = lexicon_pass(s.terms, options);
                s.terms = multiple_pass(s.terms);
                s.terms = regex_pass(s.terms);
                s.terms = interjection_fixes(s.terms);
                for (var i = 0; i < 2; i++) {
                    s.terms = grammar_pass(s);
                    s.terms = specific_noun(s.terms);
                    s.terms = ambiguous_dates(s.terms);
                    s.terms = lumper(s.terms);
                    s.terms = noun_fallback(s.terms);
                    s.terms = phrasal_verbs(s.terms);
                    s.terms = fancy_lumping(s.terms);
                    s.terms = possessive_pass(s.terms);
                }
                s.terms = conditional_pass(s.terms);
                s.terms = quotation_pass(s.terms);
                s.terms = contraction_pass(s.terms);
                return s.terms;
            };
            module.exports = tagger;
        }, {
            "./assign": 34,
            "./fancy_lumping": 35,
            "./lumper": 36,
            "./parts_of_speech": 37,
            "./passes/ambiguous_dates": 38,
            "./passes/capital_signals": 39,
            "./passes/conditional_pass": 40,
            "./passes/contractions/interpret": 41,
            "./passes/grammar_pass": 42,
            "./passes/interjection_fixes": 43,
            "./passes/lexicon_pass": 44,
            "./passes/multiples_pass": 45,
            "./passes/phrasal_verbs": 46,
            "./passes/possessive_pass": 47,
            "./passes/quotation_pass": 48,
            "./passes/regex_pass": 49
        } ],
        53: [ function(require, module, exports) {
            "use strict";
            var interrogatives = {
                who: "who",
                whose: "who",
                whom: "who",
                "which person": "who",
                where: "where",
                when: "when",
                why: "why",
                "how come": "why"
            };
            var easyForm = function easyForm(s, i) {
                var t = s.terms[i];
                var nextTerm = s.terms[i + 1];
                if (nextTerm) {
                    var twoTerm = t.normal + " " + nextTerm.normal;
                    if (interrogatives[twoTerm]) {
                        return interrogatives[twoTerm];
                    }
                }
                if (interrogatives[t.normal]) {
                    return interrogatives[t.normal];
                }
                if (interrogatives[t.expansion]) {
                    return interrogatives[t.expansion];
                }
                return false;
            };
            module.exports = easyForm;
        }, {} ],
        54: [ function(require, module, exports) {
            "use strict";
            var hardFormVerb = {
                which: "which",
                what: "what"
            };
            var knownForm = {
                time: "when",
                day: "when",
                year: "when",
                person: "who",
                amount: "number",
                number: "number"
            };
            var hardForm = function hardForm(s, i) {
                var t = s.terms[i];
                var nextTerm = s.terms[i + 1];
                var questionWord = hardFormVerb[t.normal] || hardFormVerb[t.expanded];
                if (!nextTerm || !questionWord) {
                    return null;
                }
                if (nextTerm.pos["Copula"]) {
                    return t.normal;
                }
                if (nextTerm.pos["Actor"]) {
                    return "who";
                }
                if (knownForm[nextTerm.normal]) {
                    return knownForm[nextTerm.normal];
                }
                return questionWord;
            };
            module.exports = hardForm;
        }, {} ],
        55: [ function(require, module, exports) {
            "use strict";
            var _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                };
            }();
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            }
            function _possibleConstructorReturn(self, call) {
                if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
            }
            function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var Sentence = require("../sentence.js");
            var question_form = require("./question_form");
            var Question = function(_Sentence) {
                _inherits(Question, _Sentence);
                function Question(str, options) {
                    _classCallCheck(this, Question);
                    return _possibleConstructorReturn(this, Object.getPrototypeOf(Question).call(this, str, options));
                }
                _createClass(Question, [ {
                    key: "form",
                    value: function form() {
                        return question_form(this);
                    }
                } ]);
                return Question;
            }(Sentence);
            Question.fn = Question.prototype;
            module.exports = Question;
        }, {
            "../sentence.js": 58,
            "./question_form": 56
        } ],
        56: [ function(require, module, exports) {
            "use strict";
            var yesNoTerm = require("./yesNo.js");
            var easyForm = require("./easyForm.js");
            var hardForm = require("./hardForm.js");
            var question_form = function question_form(s) {
                for (var i = 0; i < s.terms.length; i++) {
                    var form = easyForm(s, i);
                    if (form) {
                        return form;
                    }
                    form = hardForm(s, i);
                    if (form) {
                        return form;
                    }
                    if (yesNoTerm(s, i)) {
                        return "yesNo";
                    }
                }
                return null;
            };
            module.exports = question_form;
        }, {
            "./easyForm.js": 53,
            "./hardForm.js": 54,
            "./yesNo.js": 57
        } ],
        57: [ function(require, module, exports) {
            "use strict";
            var yesNoVerb = {
                is: true,
                are: true,
                was: true,
                will: true,
                "do": true,
                did: true
            };
            var yesNoTerm = function yesNoTerm(s, i) {
                var t = s.terms[i];
                var lastTerm = s.terms[i - 1];
                var nextTerm = s.terms[i + 1];
                if (yesNoVerb[t.normal] || yesNoVerb[t.expansion]) {
                    if (!lastTerm) {
                        return true;
                    }
                    if (!lastTerm) {
                        return false;
                    }
                    if (lastTerm.pos["Pronoun"] || lastTerm.pos["Person"]) {
                        return false;
                    }
                    if (nextTerm.pos["Pronoun"] || nextTerm.pos["Person"]) {
                        return true;
                    }
                }
                return false;
            };
            module.exports = yesNoTerm;
        }, {} ],
        58: [ function(require, module, exports) {
            "use strict";
            var _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                };
            }();
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            }
            var Term = require("../term/term");
            var tagger = require("./pos/tagger");
            var passive_voice = require("./passive_voice");
            var contractions = {
                contract: require("./contractions/contract"),
                expand: require("./contractions/expand")
            };
            var change_tense = require("./change_tense");
            var spot = require("./spot");
            var _match = require("../match/match");
            var tokenize_match = function tokenize_match() {};
            var Sentence = function() {
                function Sentence(str, options) {
                    _classCallCheck(this, Sentence);
                    this.str = "";
                    if (typeof str === "string") {
                        this.str = str;
                    } else if (typeof str === "number") {
                        this.str = "" + str;
                    }
                    options = options || {};
                    var the = this;
                    var words = this.str.split(/( +)/);
                    this.terms = [];
                    if (words[0] === "") {
                        words.shift();
                    }
                    for (var i = 0; i < words.length; i++) {
                        if (!words[i] || !words[i].match(/\S/i)) {
                            continue;
                        }
                        var whitespace = {
                            preceding: words[i - 1],
                            trailing: words[i + 1]
                        };
                        words[i - 1] = null;
                        words[i + 1] = null;
                        this.terms.push(new Term(words[i], null, whitespace));
                    }
                    this.terms = tagger(this, options);
                    this.contractions = {
                        expand: function expand() {
                            the.terms = contractions.expand(the.terms);
                            return the;
                        },
                        contract: function contract() {
                            the.terms = contractions.contract(the.terms);
                            return the;
                        }
                    };
                }
                _createClass(Sentence, [ {
                    key: "addBefore",
                    value: function addBefore(i, str) {
                        var t = new Term(str);
                        this.terms.splice(i, 0, t);
                    }
                }, {
                    key: "addAfter",
                    value: function addAfter(i, str) {
                        var t = new Term(str);
                        this.terms.splice(i + 1, 0, t);
                    }
                }, {
                    key: "match",
                    value: function match(match_str, options) {
                        var regs = tokenize_match(match_str);
                        return _match.findAll(this.terms, regs, options);
                    }
                }, {
                    key: "replace",
                    value: function replace(match_str, replacement, options) {
                        var regs = tokenize_match(match_str);
                        replacement = tokenize_match(replacement);
                        _match.replaceAll(this.terms, regs, replacement, options);
                        return this;
                    }
                }, {
                    key: "terminator",
                    value: function terminator() {
                        var allowed = {
                            ".": true,
                            "?": true,
                            "!": true
                        };
                        var char = this.str.match(/([\.\?\!])\W*$/);
                        if (char && allowed[char[1]]) {
                            return char[1];
                        }
                        return "";
                    }
                }, {
                    key: "tag",
                    value: function tag() {
                        this.terms = tagger(this);
                        return this.terms;
                    }
                }, {
                    key: "sentence_type",
                    value: function sentence_type() {
                        var char = this.terminator();
                        var types = {
                            "?": "interrogative",
                            "!": "exclamative",
                            ".": "declarative"
                        };
                        return types[char] || "declarative";
                    }
                }, {
                    key: "is_passive",
                    value: function is_passive() {
                        return passive_voice(this);
                    }
                }, {
                    key: "negate",
                    value: function negate() {
                        return this;
                    }
                }, {
                    key: "text",
                    value: function text() {
                        return this.terms.reduce(function(s, t) {
                            if (t.text) {
                                s += (t.whitespace.preceding || "") + t.text + (t.whitespace.trailing || "");
                            }
                            return s;
                        }, "");
                    }
                }, {
                    key: "normal",
                    value: function normal() {
                        var str = this.terms.reduce(function(s, t) {
                            if (t.normal) {
                                s += " " + t.normal;
                            }
                            return s;
                        }, "").trim();
                        return str + this.terminator();
                    }
                }, {
                    key: "root",
                    value: function root() {
                        return this.terms.reduce(function(s, t) {
                            s += " " + t.root();
                            return s;
                        }, "").trim();
                    }
                }, {
                    key: "tags",
                    value: function tags() {
                        return this.terms.map(function(t) {
                            return t.tag || "?";
                        });
                    }
                }, {
                    key: "people",
                    value: function people() {
                        return this.terms.filter(function(t) {
                            return t.pos["Person"];
                        });
                    }
                }, {
                    key: "places",
                    value: function places() {
                        return this.terms.filter(function(t) {
                            return t.pos["Place"];
                        });
                    }
                }, {
                    key: "dates",
                    value: function dates() {
                        return this.terms.filter(function(t) {
                            return t.pos["Date"];
                        });
                    }
                }, {
                    key: "organizations",
                    value: function organizations() {
                        return this.terms.filter(function(t) {
                            return t.pos["Organization"];
                        });
                    }
                }, {
                    key: "values",
                    value: function values() {
                        return this.terms.filter(function(t) {
                            return t.pos["Value"];
                        });
                    }
                }, {
                    key: "nouns",
                    value: function nouns() {
                        return this.terms.filter(function(t) {
                            return t.pos["Noun"];
                        });
                    }
                }, {
                    key: "adjectives",
                    value: function adjectives() {
                        return this.terms.filter(function(t) {
                            return t.pos["Adjective"];
                        });
                    }
                }, {
                    key: "verbs",
                    value: function verbs() {
                        return this.terms.filter(function(t) {
                            return t.pos["Verb"];
                        });
                    }
                }, {
                    key: "adverbs",
                    value: function adverbs() {
                        return this.terms.filter(function(t) {
                            return t.pos["Adverb"];
                        });
                    }
                }, {
                    key: "to_past",
                    value: function to_past() {
                        change_tense(this, "past");
                        return this;
                    }
                }, {
                    key: "to_present",
                    value: function to_present() {
                        change_tense(this, "present");
                        return this;
                    }
                }, {
                    key: "to_future",
                    value: function to_future() {
                        change_tense(this, "future");
                        return this;
                    }
                }, {
                    key: "strip_conditions",
                    value: function strip_conditions() {
                        var _this = this;
                        this.terms = this.terms.filter(function(t, i) {
                            if (i > 0 && t.pos["Condition"] && !_this.terms[i - 1].pos["Condition"]) {
                                _this.terms[i - 1].text = _this.terms[i - 1].text.replace(/,$/, "");
                                _this.terms[i - 1].whitespace.trailing = "";
                                _this.terms[i - 1].rebuild();
                            }
                            return !t.pos["Condition"];
                        });
                        return this;
                    }
                }, {
                    key: "word_count",
                    value: function word_count() {
                        return this.terms.filter(function(t) {
                            if (t.normal === "") {
                                return false;
                            }
                            return true;
                        }).length;
                    }
                }, {
                    key: "topics",
                    value: function topics() {
                        return spot(this);
                    }
                } ]);
                return Sentence;
            }();
            tokenize_match = function tokenize_match(str) {
                var regs = new Sentence(str).terms;
                regs = regs.map(function(t) {
                    return t.text;
                });
                regs = regs.filter(function(t) {
                    return t !== "";
                });
                return regs;
            };
            Sentence.fn = Sentence.prototype;
            module.exports = Sentence;
        }, {
            "../match/match": 26,
            "../term/term": 97,
            "./change_tense": 30,
            "./contractions/contract": 31,
            "./contractions/expand": 32,
            "./passive_voice": 33,
            "./pos/tagger": 52,
            "./spot": 59
        } ],
        59: [ function(require, module, exports) {
            "use strict";
            var blacklist = {
                man: true,
                woman: true,
                girl: true,
                boy: true,
                guy: true,
                father: true,
                mother: true,
                sister: true,
                brother: true
            };
            var consolidate = function consolidate(topics) {
                var names = {};
                for (var i = 0; i < topics.length; i++) {
                    var normal = topics[i].root();
                    if (normal) {
                        names[normal] = names[normal] || {
                            count: 0,
                            text: normal
                        };
                        names[normal].count += 1;
                    }
                }
                var arr = Object.keys(names).map(function(k) {
                    return names[k];
                });
                return arr.sort(function(a, b) {
                    if (a.count > b.count) {
                        return -1;
                    } else {
                        return 1;
                    }
                });
            };
            var spot = function spot(s) {
                var topics = [];
                for (var i = 0; i < s.terms.length; i++) {
                    var t = s.terms[i];
                    if (blacklist[t.normal]) {
                        continue;
                    }
                    if (t.pos["Place"] || t.pos["Organization"]) {
                        topics.push(t);
                        continue;
                    }
                    if (t.pos["Person"] && !t.pos["Pronoun"]) {
                        topics.push(t);
                        continue;
                    }
                    if (i !== 0 && t.pos["Noun"] && t.is_capital()) {
                        if (t.pos["Value"] || t.pos["Date"] || t.pos["Pronoun"]) {
                            continue;
                        }
                        topics.push(t);
                    }
                }
                return consolidate(topics);
            };
            module.exports = spot;
        }, {} ],
        60: [ function(require, module, exports) {
            "use strict";
            var fns = require("../../../fns");
            var logical_negate = {
                everyone: "no one",
                everybody: "nobody",
                someone: "no one",
                somebody: "nobody",
                always: "never"
            };
            var logical_affirm = fns.reverseObj(logical_negate);
            logical_affirm["nobody"] = "somebody";
            var negate = function negate(s) {
                var _loop = function _loop(i) {
                    var t = s.terms[i];
                    if (t.pos["Condition"] || t.pos["Quotation"]) {
                        return "continue";
                    }
                    if (logical_negate[t.normal]) {
                        t.changeTo(logical_negate[t.normal]);
                        return "break";
                    }
                    if (logical_affirm[t.normal]) {
                        t.changeTo(logical_affirm[t.normal]);
                        return "break";
                    }
                    if (t.pos["Verb"]) {
                        var isPronounAndInfinitive = function isPronounAndInfinitive() {
                            if (s.terms[i - 1]) {
                                var p = s.terms[i - 1].text;
                                return (p === "i" || p === "we" || p === "they" || p === "you") && t.pos["Infinitive"];
                            }
                            return false;
                        };
                        if (isPronounAndInfinitive()) {
                            t.changeTo("don't " + t.text);
                            return "break";
                        }
                        t.negate();
                        return "break";
                    }
                };
                _loop2: for (var i = 0; i < s.terms.length; i++) {
                    var _ret = _loop(i);
                    switch (_ret) {
                      case "continue":
                        continue;

                      case "break":
                        break _loop2;
                    }
                }
                return;
            };
            module.exports = negate;
        }, {
            "../../../fns": 23
        } ],
        61: [ function(require, module, exports) {
            "use strict";
            var _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                };
            }();
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            }
            function _possibleConstructorReturn(self, call) {
                if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
            }
            function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var Sentence = require("../sentence.js");
            var _negate = require("./negate/negate.js");
            var Statement = function(_Sentence) {
                _inherits(Statement, _Sentence);
                function Statement(str, options) {
                    _classCallCheck(this, Statement);
                    return _possibleConstructorReturn(this, Object.getPrototypeOf(Statement).call(this, str, options));
                }
                _createClass(Statement, [ {
                    key: "negate",
                    value: function negate() {
                        _negate(this);
                        return this;
                    }
                } ]);
                return Statement;
            }(Sentence);
            Statement.fn = Statement.prototype;
            module.exports = Statement;
        }, {
            "../sentence.js": 58,
            "./negate/negate.js": 60
        } ],
        62: [ function(require, module, exports) {
            "use strict";
            var _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                };
            }();
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            }
            function _possibleConstructorReturn(self, call) {
                if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
            }
            function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var Term = require("../term.js");
            var _to_comparative = require("./to_comparative");
            var _to_superlative = require("./to_superlative");
            var adj_to_adv = require("./to_adverb");
            var adj_to_noun = require("./to_noun");
            var Adjective = function(_Term) {
                _inherits(Adjective, _Term);
                function Adjective(str, tag) {
                    _classCallCheck(this, Adjective);
                    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Adjective).call(this, str));
                    _this.tag = tag;
                    if (tag) {
                        _this.pos[tag] = true;
                    }
                    _this.pos["Adjective"] = true;
                    return _this;
                }
                _createClass(Adjective, [ {
                    key: "to_comparative",
                    value: function to_comparative() {
                        return _to_comparative(this.normal);
                    }
                }, {
                    key: "to_superlative",
                    value: function to_superlative() {
                        return _to_superlative(this.normal);
                    }
                }, {
                    key: "to_noun",
                    value: function to_noun() {
                        return adj_to_noun(this.normal);
                    }
                }, {
                    key: "to_adverb",
                    value: function to_adverb() {
                        return adj_to_adv(this.normal);
                    }
                }, {
                    key: "conjugate",
                    value: function conjugate() {
                        return {
                            comparative: _to_comparative(this.normal),
                            superlative: _to_superlative(this.normal),
                            adverb: adj_to_adv(this.normal),
                            noun: adj_to_noun(this.normal)
                        };
                    }
                } ]);
                return Adjective;
            }(Term);
            Adjective.fn = Adjective.prototype;
            module.exports = Adjective;
        }, {
            "../term.js": 97,
            "./to_adverb": 63,
            "./to_comparative": 64,
            "./to_noun": 65,
            "./to_superlative": 66
        } ],
        63: [ function(require, module, exports) {
            "use strict";
            var adj_to_adv = function adj_to_adv(str) {
                var irregulars = {
                    idle: "idly",
                    "public": "publicly",
                    vague: "vaguely",
                    day: "daily",
                    icy: "icily",
                    single: "singly",
                    female: "womanly",
                    male: "manly",
                    simple: "simply",
                    whole: "wholly",
                    special: "especially",
                    straight: "straight",
                    wrong: "wrong",
                    fast: "fast",
                    hard: "hard",
                    late: "late",
                    early: "early",
                    well: "well",
                    good: "well",
                    little: "little",
                    "long": "long",
                    low: "low",
                    best: "best",
                    latter: "latter",
                    bad: "badly"
                };
                var dont = {
                    foreign: 1,
                    black: 1,
                    modern: 1,
                    next: 1,
                    difficult: 1,
                    degenerate: 1,
                    young: 1,
                    awake: 1,
                    back: 1,
                    blue: 1,
                    brown: 1,
                    orange: 1,
                    complex: 1,
                    cool: 1,
                    dirty: 1,
                    done: 1,
                    empty: 1,
                    fat: 1,
                    fertile: 1,
                    frozen: 1,
                    gold: 1,
                    grey: 1,
                    gray: 1,
                    green: 1,
                    medium: 1,
                    parallel: 1,
                    outdoor: 1,
                    unknown: 1,
                    undersized: 1,
                    used: 1,
                    welcome: 1,
                    yellow: 1,
                    white: 1,
                    fixed: 1,
                    mixed: 1,
                    "super": 1,
                    guilty: 1,
                    tiny: 1,
                    able: 1,
                    unable: 1,
                    same: 1,
                    adult: 1
                };
                var transforms = [ {
                    reg: /al$/i,
                    repl: "ally"
                }, {
                    reg: /ly$/i,
                    repl: "ly"
                }, {
                    reg: /(.{3})y$/i,
                    repl: "$1ily"
                }, {
                    reg: /que$/i,
                    repl: "quely"
                }, {
                    reg: /ue$/i,
                    repl: "uly"
                }, {
                    reg: /ic$/i,
                    repl: "ically"
                }, {
                    reg: /ble$/i,
                    repl: "bly"
                }, {
                    reg: /l$/i,
                    repl: "ly"
                } ];
                var not_matches = [ /airs$/, /ll$/, /ee.$/, /ile$/ ];
                if (dont[str]) {
                    return null;
                }
                if (irregulars[str]) {
                    return irregulars[str];
                }
                if (str.length <= 3) {
                    return null;
                }
                for (var i = 0; i < not_matches.length; i++) {
                    if (str.match(not_matches[i])) {
                        return null;
                    }
                }
                for (var i = 0; i < transforms.length; i++) {
                    if (str.match(transforms[i].reg)) {
                        return str.replace(transforms[i].reg, transforms[i].repl);
                    }
                }
                return str + "ly";
            };
            module.exports = adj_to_adv;
        }, {} ],
        64: [ function(require, module, exports) {
            "use strict";
            var convertables = require("../../data/convertables.js");
            var to_comparative = function to_comparative(str) {
                var irregulars = {
                    grey: "greyer",
                    gray: "grayer",
                    green: "greener",
                    yellow: "yellower",
                    red: "redder",
                    good: "better",
                    well: "better",
                    bad: "worse",
                    sad: "sadder"
                };
                var dont = {
                    overweight: 1,
                    main: 1,
                    nearby: 1,
                    asleep: 1,
                    weekly: 1,
                    secret: 1,
                    certain: 1
                };
                var transforms = [ {
                    reg: /y$/i,
                    repl: "ier"
                }, {
                    reg: /([aeiou])t$/i,
                    repl: "$1tter"
                }, {
                    reg: /([aeou])de$/i,
                    repl: "$1der"
                }, {
                    reg: /nge$/i,
                    repl: "nger"
                } ];
                var matches = [ /ght$/, /nge$/, /ough$/, /ain$/, /uel$/, /[au]ll$/, /ow$/, /old$/, /oud$/, /e[ae]p$/ ];
                var not_matches = [ /ary$/, /ous$/ ];
                if (dont.hasOwnProperty(str)) {
                    return null;
                }
                for (var i = 0; i < transforms.length; i++) {
                    if (str.match(transforms[i].reg)) {
                        return str.replace(transforms[i].reg, transforms[i].repl);
                    }
                }
                if (convertables.hasOwnProperty(str)) {
                    if (str.match(/e$/)) {
                        return str + "r";
                    }
                    return str + "er";
                }
                if (irregulars.hasOwnProperty(str)) {
                    return irregulars[str];
                }
                for (var i = 0; i < not_matches.length; i++) {
                    if (str.match(not_matches[i])) {
                        return "more " + str;
                    }
                }
                for (var i = 0; i < matches.length; i++) {
                    if (str.match(matches[i])) {
                        return str + "er";
                    }
                }
                return "more " + str;
            };
            module.exports = to_comparative;
        }, {
            "../../data/convertables.js": 3
        } ],
        65: [ function(require, module, exports) {
            "use strict";
            var to_noun = function to_noun(w) {
                var irregulars = {
                    clean: "cleanliness",
                    naivety: "naivety"
                };
                if (!w) {
                    return "";
                }
                if (irregulars.hasOwnProperty(w)) {
                    return irregulars[w];
                }
                if (w.match(" ")) {
                    return w;
                }
                if (w.match(/w$/)) {
                    return w;
                }
                var transforms = [ {
                    reg: /y$/,
                    repl: "iness"
                }, {
                    reg: /le$/,
                    repl: "ility"
                }, {
                    reg: /ial$/,
                    repl: "y"
                }, {
                    reg: /al$/,
                    repl: "ality"
                }, {
                    reg: /ting$/,
                    repl: "ting"
                }, {
                    reg: /ring$/,
                    repl: "ring"
                }, {
                    reg: /bing$/,
                    repl: "bingness"
                }, {
                    reg: /sing$/,
                    repl: "se"
                }, {
                    reg: /ing$/,
                    repl: "ment"
                }, {
                    reg: /ess$/,
                    repl: "essness"
                }, {
                    reg: /ous$/,
                    repl: "ousness"
                } ];
                for (var i = 0; i < transforms.length; i++) {
                    if (w.match(transforms[i].reg)) {
                        return w.replace(transforms[i].reg, transforms[i].repl);
                    }
                }
                if (w.match(/s$/)) {
                    return w;
                }
                return w + "ness";
            };
            module.exports = to_noun;
        }, {} ],
        66: [ function(require, module, exports) {
            "use strict";
            var convertables = require("../../data/convertables.js");
            var to_superlative = function to_superlative(str) {
                var irregulars = {
                    nice: "nicest",
                    late: "latest",
                    hard: "hardest",
                    inner: "innermost",
                    outer: "outermost",
                    far: "furthest",
                    worse: "worst",
                    bad: "worst",
                    good: "best"
                };
                var dont = {
                    overweight: 1,
                    ready: 1
                };
                var transforms = [ {
                    reg: /y$/i,
                    repl: "iest"
                }, {
                    reg: /([aeiou])t$/i,
                    repl: "$1ttest"
                }, {
                    reg: /([aeou])de$/i,
                    repl: "$1dest"
                }, {
                    reg: /nge$/i,
                    repl: "ngest"
                } ];
                var matches = [ /ght$/, /nge$/, /ough$/, /ain$/, /uel$/, /[au]ll$/, /ow$/, /oud$/, /...p$/ ];
                var not_matches = [ /ary$/ ];
                var generic_transformation = function generic_transformation(s) {
                    if (s.match(/e$/)) {
                        return s + "st";
                    }
                    return s + "est";
                };
                for (var i = 0; i < transforms.length; i++) {
                    if (str.match(transforms[i].reg)) {
                        return str.replace(transforms[i].reg, transforms[i].repl);
                    }
                }
                if (convertables.hasOwnProperty(str)) {
                    return generic_transformation(str);
                }
                if (dont.hasOwnProperty(str)) {
                    return "most " + str;
                }
                if (irregulars.hasOwnProperty(str)) {
                    return irregulars[str];
                }
                for (var i = 0; i < not_matches.length; i++) {
                    if (str.match(not_matches[i])) {
                        return "most " + str;
                    }
                }
                for (var i = 0; i < matches.length; i++) {
                    if (str.match(matches[i])) {
                        return generic_transformation(str);
                    }
                }
                return "most " + str;
            };
            module.exports = to_superlative;
        }, {
            "../../data/convertables.js": 3
        } ],
        67: [ function(require, module, exports) {
            "use strict";
            var _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                };
            }();
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            }
            function _possibleConstructorReturn(self, call) {
                if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
            }
            function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var Term = require("../term.js");
            var _to_adjective = require("./to_adjective.js");
            var Adverb = function(_Term) {
                _inherits(Adverb, _Term);
                function Adverb(str, tag) {
                    _classCallCheck(this, Adverb);
                    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Adverb).call(this, str));
                    _this.tag = tag;
                    _this.pos["Adverb"] = true;
                    return _this;
                }
                _createClass(Adverb, [ {
                    key: "to_adjective",
                    value: function to_adjective() {
                        return _to_adjective(this.normal);
                    }
                } ]);
                return Adverb;
            }(Term);
            Adverb.fn = Adverb.prototype;
            module.exports = Adverb;
        }, {
            "../term.js": 97,
            "./to_adjective.js": 68
        } ],
        68: [ function(require, module, exports) {
            "use strict";
            var to_adjective = function to_adjective(str) {
                var irregulars = {
                    idly: "idle",
                    sporadically: "sporadic",
                    basically: "basic",
                    grammatically: "grammatical",
                    alphabetically: "alphabetical",
                    economically: "economical",
                    conically: "conical",
                    politically: "political",
                    vertically: "vertical",
                    practically: "practical",
                    theoretically: "theoretical",
                    critically: "critical",
                    fantastically: "fantastic",
                    mystically: "mystical",
                    pornographically: "pornographic",
                    fully: "full",
                    jolly: "jolly",
                    wholly: "whole"
                };
                var transforms = [ {
                    reg: /bly$/i,
                    repl: "ble"
                }, {
                    reg: /gically$/i,
                    repl: "gical"
                }, {
                    reg: /([rsdh])ically$/i,
                    repl: "$1ical"
                }, {
                    reg: /ically$/i,
                    repl: "ic"
                }, {
                    reg: /uly$/i,
                    repl: "ue"
                }, {
                    reg: /ily$/i,
                    repl: "y"
                }, {
                    reg: /(.{3})ly$/i,
                    repl: "$1"
                } ];
                if (irregulars.hasOwnProperty(str)) {
                    return irregulars[str];
                }
                for (var i = 0; i < transforms.length; i++) {
                    if (str.match(transforms[i].reg)) {
                        return str.replace(transforms[i].reg, transforms[i].repl);
                    }
                }
                return str;
            };
            module.exports = to_adjective;
        }, {} ],
        69: [ function(require, module, exports) {
            "use strict";
            var implications = {
                plz: "please",
                tmrw: "tomorrow",
                wat: "what",
                r: "are",
                u: "you"
            };
            var implied = function implied(str) {
                if (implications[str]) {
                    return implications[str];
                }
                return null;
            };
            module.exports = implied;
        }, {} ],
        70: [ function(require, module, exports) {
            "use strict";
            var is_acronym = function is_acronym(str) {
                if (str.match(/([A-Z]\.)+[A-Z]?$/)) {
                    return true;
                }
                if (str.match(/[A-Z]{3}$/)) {
                    return true;
                }
                return false;
            };
            module.exports = is_acronym;
        }, {} ],
        71: [ function(require, module, exports) {
            "use strict";
            var is_acronym = require("../is_acronym.js");
            var irregulars = {
                hour: "an",
                heir: "an",
                heirloom: "an",
                honest: "an",
                honour: "an",
                honor: "an",
                uber: "an"
            };
            var indefinite_article = function indefinite_article(str) {
                if (!str) {
                    return null;
                }
                var an_acronyms = {
                    A: true,
                    E: true,
                    F: true,
                    H: true,
                    I: true,
                    L: true,
                    M: true,
                    N: true,
                    O: true,
                    R: true,
                    S: true,
                    X: true
                };
                var a_regexs = [ /^onc?e/i, /^u[bcfhjkqrstn][aeiou]/i, /^eul/i ];
                if (irregulars.hasOwnProperty(str)) {
                    return irregulars[str];
                }
                if (is_acronym(str) && an_acronyms.hasOwnProperty(str.substr(0, 1))) {
                    return "an";
                }
                for (var i = 0; i < a_regexs.length; i++) {
                    if (str.match(a_regexs[i])) {
                        return "a";
                    }
                }
                if (str.match(/^[aeiou]/i)) {
                    return "an";
                }
                return "a";
            };
            module.exports = indefinite_article;
        }, {
            "../is_acronym.js": 70
        } ],
        72: [ function(require, module, exports) {
            "use strict";
            var _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                };
            }();
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            }
            function _possibleConstructorReturn(self, call) {
                if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
            }
            function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var Noun = require("../noun.js");
            var parse_date = require("./parse_date.js");
            var _Date = function(_Noun) {
                _inherits(_Date, _Noun);
                function _Date(str, tag) {
                    _classCallCheck(this, _Date);
                    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(_Date).call(this, str));
                    _this.tag = tag;
                    _this.pos["Date"] = true;
                    _this.data = parse_date(_this.text) || {};
                    return _this;
                }
                _createClass(_Date, [ {
                    key: "is_date",
                    value: function is_date() {
                        var o = this.data;
                        if (o.month === null || o.day === null || o.year === null) {
                            return false;
                        }
                        return true;
                    }
                }, {
                    key: "date",
                    value: function date() {
                        if (this.is_date() === false) {
                            return null;
                        }
                        var d = new Date();
                        if (this.data.year) {
                            d.setYear(this.data.year);
                        }
                        if (this.data.month !== null) {
                            d.setMonth(this.data.month);
                        }
                        if (this.data.day !== null) {
                            d.setDate(this.data.day);
                        }
                        return d;
                    }
                } ]);
                return _Date;
            }(Noun);
            _Date.fn = _Date.prototype;
            module.exports = _Date;
        }, {
            "../noun.js": 78,
            "./parse_date.js": 75
        } ],
        73: [ function(require, module, exports) {
            "use strict";
            var months = require("../../../data/dates").months.concat([ "march", "may" ]);
            var month = "(" + months.join("|") + ")";
            var day = "([0-9]{1,2})";
            var year = "'?([12][0-9]{3})";
            var rules = [ {
                reg: month + " " + day + " " + year,
                order: [ "month", "day", "year" ]
            }, {
                reg: day + " of " + month + " " + year,
                order: [ "day", "month", "year" ]
            }, {
                reg: day + " of " + month,
                order: [ "day", "month" ]
            }, {
                reg: month + " " + year,
                order: [ "month", "year" ]
            }, {
                reg: month + " " + day,
                order: [ "month", "day" ]
            }, {
                reg: day + " " + month,
                order: [ "day", "month" ]
            }, {
                reg: "" + month,
                order: [ "month" ]
            }, {
                reg: "" + year,
                order: [ "year" ]
            } ].map(function(o) {
                o.reg = new RegExp("\\b" + o.reg + "\\b", "");
                return o;
            });
            module.exports = rules;
        }, {
            "../../../data/dates": 5
        } ],
        74: [ function(require, module, exports) {
            "use strict";
            var dates = require("../../../data/dates");
            var terms = dates.months.concat(dates.days);
            var day_reg = "(\\b" + terms.join("\\b|\\b") + "\\b)";
            day_reg = new RegExp(day_reg, "i");
            var times_reg = /1?[0-9]:[0-9]{2}/;
            var is_date = function is_date(str) {
                if (str.match(day_reg) || str.match(times_reg)) {
                    return true;
                }
                if (str.match(/^[12][0-9]{3}$/)) {
                    var n = parseInt(str, 10);
                    if (n > 1300 && n < 2100) {
                        return true;
                    }
                }
                return false;
            };
            module.exports = is_date;
        }, {
            "../../../data/dates": 5
        } ],
        75: [ function(require, module, exports) {
            "use strict";
            var to_number = require("../value/parse/to_number.js");
            var rules = require("./date_rules.js");
            var wrangle = {
                year: function year(s) {
                    var num = s.match(/[0-9]+/);
                    num = parseInt(num, 10);
                    if (!num || num > 2900 || num < 0) {
                        return null;
                    }
                    if (num > 100 && num < 1e3) {
                        return null;
                    }
                    if (s.match(/[0-9] ?bc/i)) {
                        return num *= -1;
                    }
                    if (num < 100 && num > 30) {
                        num += 1900;
                    }
                    return num;
                },
                month: function month(s) {
                    var months_obj = {
                        january: 0,
                        february: 1,
                        march: 2,
                        april: 3,
                        may: 4,
                        june: 5,
                        july: 6,
                        august: 7,
                        september: 8,
                        october: 9,
                        november: 10,
                        december: 11,
                        jan: 0,
                        feb: 1,
                        mar: 2,
                        apr: 3,
                        aug: 7,
                        sept: 8,
                        oct: 9,
                        nov: 10,
                        dec: 11
                    };
                    return months_obj[s];
                },
                day: function day(s) {
                    var n = to_number(s) || parseInt(s, 10);
                    if (n < 0 || n > 31) {
                        return null;
                    }
                    return n;
                }
            };
            var preprocess = function preprocess(str) {
                str = str.toLowerCase();
                str = str.replace(/([0-9]+)(nd|rd|th|st)/i, "$1");
                var words = str.split(" ").map(function(w) {
                    if (!w.match(/[0-9]/)) {
                        return to_number(w) || w;
                    }
                    return w;
                });
                return words.join(" ");
            };
            var date_parser = function date_parser(str) {
                str = preprocess(str);
                var result = {
                    year: null,
                    month: null,
                    day: null
                };
                for (var i = 0; i < rules.length; i++) {
                    if (str.match(rules[i].reg)) {
                        var m = str.match(rules[i].reg);
                        for (var o = 0; o < rules[i].order.length; o++) {
                            var type = rules[i].order[o];
                            result[type] = wrangle[type](m[o + 1]);
                        }
                        break;
                    }
                }
                return result;
            };
            module.exports = date_parser;
        }, {
            "../value/parse/to_number.js": 93,
            "./date_rules.js": 73
        } ],
        76: [ function(require, module, exports) {
            "use strict";
            var irregulars = require("../../data/irregular_nouns");
            var plural_indicators = [ /(^v)ies$/i, /ises$/i, /ives$/i, /(antenn|formul|nebul|vertebr|vit)ae$/i, /(octop|vir|radi|nucle|fung|cact|stimul)i$/i, /(buffal|tomat|tornad)oes$/i, /(analy|ba|diagno|parenthe|progno|synop|the)ses$/i, /(vert|ind|cort)ices$/i, /(matr|append)ices$/i, /(x|ch|ss|sh|s|z|o)es$/i, /men$/i, /news$/i, /.tia$/i, /(^f)ves$/i, /(lr)ves$/i, /(^aeiouy|qu)ies$/i, /(m|l)ice$/i, /(cris|ax|test)es$/i, /(alias|status)es$/i, /ics$/i ];
            var singular_indicators = [ /(ax|test)is$/i, /(octop|vir|radi|nucle|fung|cact|stimul)us$/i, /(octop|vir)i$/i, /(rl)f$/i, /(alias|status)$/i, /(bu)s$/i, /(al|ad|at|er|et|ed|ad)o$/i, /(ti)um$/i, /(ti)a$/i, /sis$/i, /(?:(^f)fe|(lr)f)$/i, /hive$/i, /(^aeiouy|qu)y$/i, /(x|ch|ss|sh|z)$/i, /(matr|vert|ind|cort)(ix|ex)$/i, /(m|l)ouse$/i, /(m|l)ice$/i, /(antenn|formul|nebul|vertebr|vit)a$/i, /.sis$/i, /^(?!talis|.*hu)(.*)man$/i ];
            var is_plural = function is_plural(str) {
                str = (str || "").toLowerCase();
                var preposition = str.match(/([a-z]*) (of|in|by|for) [a-z]/);
                if (preposition && preposition[1]) {
                    str = preposition[1];
                }
                for (var i = 0; i < irregulars.length; i++) {
                    if (irregulars[i][1] === str) {
                        return true;
                    }
                    if (irregulars[i][0] === str) {
                        return false;
                    }
                }
                for (var i = 0; i < plural_indicators.length; i++) {
                    if (str.match(plural_indicators[i])) {
                        return true;
                    }
                }
                for (var i = 0; i < singular_indicators.length; i++) {
                    if (str.match(singular_indicators[i])) {
                        return false;
                    }
                }
                if (str.match(/s$/) && !str.match(/ss$/) && str.length > 3) {
                    return true;
                }
                return false;
            };
            module.exports = is_plural;
        }, {
            "../../data/irregular_nouns": 10
        } ],
        77: [ function(require, module, exports) {
            "use strict";
            var uncountable_arr = require("../../data/uncountables.js");
            var uncountable = uncountable_arr.reduce(function(h, a) {
                h[a] = true;
                return h;
            }, {});
            var is_uncountable = function is_uncountable(str) {
                if (uncountable[str]) {
                    return true;
                }
                return false;
            };
            module.exports = is_uncountable;
        }, {
            "../../data/uncountables.js": 21
        } ],
        78: [ function(require, module, exports) {
            "use strict";
            var _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                };
            }();
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            }
            function _possibleConstructorReturn(self, call) {
                if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
            }
            function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var Term = require("../term.js");
            var _article = require("./article.js");
            var _is_plural = require("./is_plural.js");
            var _is_place = require("./place/is_place.js");
            var _is_person = require("./person/is_person.js");
            var _pronoun = require("./pronoun.js");
            var _is_value = require("./value/is_value.js");
            var _is_date = require("./date/is_date.js");
            var _is_organization = require("./organization/is_organization.js");
            var _singularize = require("./singularize.js");
            var _pluralize = require("./pluralize.js");
            var _is_uncountable = require("./is_uncountable.js");
            var Noun = function(_Term) {
                _inherits(Noun, _Term);
                function Noun(str, tag) {
                    _classCallCheck(this, Noun);
                    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Noun).call(this, str));
                    _this.tag = tag;
                    _this.pos["Noun"] = true;
                    if (tag) {
                        _this.pos[tag] = true;
                    }
                    if (_this.is_plural()) {
                        _this.pos["Plural"] = true;
                    }
                    return _this;
                }
                _createClass(Noun, [ {
                    key: "article",
                    value: function article() {
                        if (this.pos["Person"]) {
                            return this.pronoun();
                        }
                        if (this.pos["Organization"]) {
                            return "they";
                        }
                        return _article(this.text);
                    }
                }, {
                    key: "root",
                    value: function root() {
                        return this.singularize();
                    }
                }, {
                    key: "pronoun",
                    value: function pronoun() {
                        if (this.is_organization() || this.is_place() || this.is_value()) {
                            return "it";
                        }
                        return _pronoun(this.normal);
                    }
                }, {
                    key: "is_plural",
                    value: function is_plural() {
                        if (this.pos["Date"] || this.pos["Possessive"]) {
                            return false;
                        } else if (this.has_abbreviation()) {
                            return false;
                        } else {
                            return _is_plural(this.normal);
                        }
                    }
                }, {
                    key: "is_uncountable",
                    value: function is_uncountable() {
                        return _is_uncountable(this.strip_apostrophe());
                    }
                }, {
                    key: "pluralize",
                    value: function pluralize() {
                        return _pluralize(this.strip_apostrophe());
                    }
                }, {
                    key: "singularize",
                    value: function singularize() {
                        return _singularize(this.strip_apostrophe());
                    }
                }, {
                    key: "is_person",
                    value: function is_person() {
                        if (this.tag === "Date") {
                            return false;
                        }
                        return _is_person(this.strip_apostrophe());
                    }
                }, {
                    key: "is_organization",
                    value: function is_organization() {
                        return _is_organization(this.strip_apostrophe(), this.text);
                    }
                }, {
                    key: "is_date",
                    value: function is_date() {
                        return _is_date(this.strip_apostrophe());
                    }
                }, {
                    key: "is_value",
                    value: function is_value() {
                        if (this.tag === "Date") {
                            return false;
                        }
                        return _is_value(this.strip_apostrophe());
                    }
                }, {
                    key: "is_place",
                    value: function is_place() {
                        return _is_place(this.strip_apostrophe());
                    }
                } ]);
                return Noun;
            }(Term);
            Noun.fn = Noun.prototype;
            module.exports = Noun;
        }, {
            "../term.js": 97,
            "./article.js": 71,
            "./date/is_date.js": 74,
            "./is_plural.js": 76,
            "./is_uncountable.js": 77,
            "./organization/is_organization.js": 79,
            "./person/is_person.js": 82,
            "./place/is_place.js": 85,
            "./pluralize.js": 87,
            "./pronoun.js": 88,
            "./singularize.js": 89,
            "./value/is_value.js": 90
        } ],
        79: [ function(require, module, exports) {
            "use strict";
            var abbreviations = require("../../../data/abbreviations");
            var org_data = require("../../../data/organizations");
            var blacklist = {
                url: true,
                http: true,
                wtf: true,
                irl: true,
                ie: true,
                eg: true,
                gps: true,
                dna: true,
                sms: true
            };
            var org_suffix = abbreviations.orgs.reduce(function(h, s) {
                h[s] = true;
                return h;
            }, {});
            org_data.suffixes.forEach(function(s) {
                org_suffix[s] = true;
            });
            var org_names = org_data.organizations.reduce(function(h, s) {
                h[s] = true;
                return h;
            }, {});
            var is_organization = function is_organization(str, text) {
                text = text || "";
                if (blacklist[str]) {
                    return false;
                }
                if (org_names[str]) {
                    return true;
                }
                if (text.length <= 5 && text.match(/^[A-Z][A-Z]+$/) !== null) {
                    return true;
                }
                if (text.length >= 4 && text.match(/^([A-Z]\.)*$/) !== null) {
                    return true;
                }
                if (str.match(/ & /)) {
                    return true;
                }
                if (str.match(/..s of /)) {
                    return true;
                }
                if (str.match(/[a-z]{3}\.(com|net|org|biz)/)) {
                    return true;
                }
                var words = str.split(" ");
                if (words.length > 1) {
                    var last = words[words.length - 1];
                    if (org_suffix[last]) {
                        return true;
                    }
                }
                return false;
            };
            module.exports = is_organization;
        }, {
            "../../../data/abbreviations": 1,
            "../../../data/organizations": 17
        } ],
        80: [ function(require, module, exports) {
            "use strict";
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            }
            function _possibleConstructorReturn(self, call) {
                if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
            }
            function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var Noun = require("../noun.js");
            var Organization = function(_Noun) {
                _inherits(Organization, _Noun);
                function Organization(str, tag) {
                    _classCallCheck(this, Organization);
                    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Organization).call(this, str));
                    _this.tag = tag;
                    _this.pos["Organization"] = true;
                    return _this;
                }
                return Organization;
            }(Noun);
            Organization.fn = Organization.prototype;
            module.exports = Organization;
        }, {
            "../noun.js": 78
        } ],
        81: [ function(require, module, exports) {
            "use strict";
            var firstnames = require("../../../data/firstnames");
            var parse_name = require("./parse_name.js");
            var gender = function gender(normal) {
                if (normal === "he") {
                    return "Male";
                }
                if (normal === "she") {
                    return "Female";
                }
                var o = parse_name(normal);
                var firstName = o.firstName;
                if (!firstName) {
                    return null;
                }
                if (firstnames[firstName] === "m") {
                    return "Male";
                }
                if (firstnames[firstName] === "f") {
                    return "Female";
                }
                if (normal.match(/\b(mr|mister|sr|jr)\b/i)) {
                    return "Male";
                }
                if (normal.match(/^(mrs|miss|ms|misses|mme|mlle)\.? /i)) {
                    return "Female";
                }
                if (firstName.match(/.(i|ee|[a|e]y|a)$/i)) {
                    return "Female";
                }
                if (firstName.match(/[ou]$/i)) {
                    return "Male";
                }
                if (firstName.match(/(nn|ll|tt)/i)) {
                    return "Female";
                }
                return null;
            };
            module.exports = gender;
        }, {
            "../../../data/firstnames": 7,
            "./parse_name.js": 83
        } ],
        82: [ function(require, module, exports) {
            "use strict";
            var firstnames = require("../../../data/firstnames");
            var honourifics = require("../../../data/honourifics").reduce(function(h, s) {
                h[s] = true;
                return h;
            }, {});
            var whitelist = {
                he: true,
                she: true,
                i: true,
                you: true
            };
            var is_person = function is_person(str) {
                if (whitelist[str] || firstnames[str]) {
                    return true;
                }
                var words = str.split(" ");
                if (words.length > 1) {
                    var first = words[0];
                    if (honourifics[first] || firstnames[first]) {
                        return true;
                    }
                }
                return false;
            };
            module.exports = is_person;
        }, {
            "../../../data/firstnames": 7,
            "../../../data/honourifics": 9
        } ],
        83: [ function(require, module, exports) {
            "use strict";
            var firstnames = require("../../../data/firstnames");
            var honourifics = require("../../../data/honourifics").reduce(function(h, s) {
                h[s] = true;
                return h;
            }, {});
            var parse_name = function parse_name(str) {
                var words = str.split(" ");
                var o = {
                    honourific: null,
                    firstName: null,
                    middleName: null,
                    lastName: null
                };
                if (honourifics[words[0]]) {
                    o.honourific = words[0];
                    words = words.slice(1, words.length);
                }
                if (honourifics[words[words.length - 1]]) {
                    o.honourific = words[words.length - 1];
                    words = words.slice(0, words.length - 1);
                }
                if (firstnames[words[0]]) {
                    o.firstName = words[0];
                    words = words.slice(1, words.length);
                } else {
                    if (words.length === 1) {
                        return o;
                    }
                    o.firstName = words[0];
                    words = words.slice(1, words.length);
                }
                if (words[words.length - 1]) {
                    o.lastName = words[words.length - 1];
                    words = words.slice(0, words.length - 1);
                }
                o.middleName = words.join(" ");
                return o;
            };
            module.exports = parse_name;
        }, {
            "../../../data/firstnames": 7,
            "../../../data/honourifics": 9
        } ],
        84: [ function(require, module, exports) {
            "use strict";
            var _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                };
            }();
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            }
            function _possibleConstructorReturn(self, call) {
                if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
            }
            function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var Noun = require("../noun.js");
            var guess_gender = require("./gender.js");
            var parse_name = require("./parse_name.js");
            var Person = function(_Noun) {
                _inherits(Person, _Noun);
                function Person(str, tag) {
                    _classCallCheck(this, Person);
                    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Person).call(this, str));
                    _this.tag = tag;
                    _this.pos["Person"] = true;
                    _this.honourific = null;
                    _this.firstName = null;
                    _this.middleName = null;
                    _this.lastName = null;
                    _this.parse();
                    if (_this.isPronoun()) {
                        _this.pos["Pronoun"] = true;
                    }
                    return _this;
                }
                _createClass(Person, [ {
                    key: "isPronoun",
                    value: function isPronoun() {
                        var whitelist = {
                            he: true,
                            she: true,
                            i: true,
                            you: true
                        };
                        return whitelist[this.normal];
                    }
                }, {
                    key: "root",
                    value: function root() {
                        if (this.isPronoun()) {
                            return this.normal;
                        }
                        var str = this.firstName || "";
                        if (this.middleName) {
                            str += " " + this.middleName;
                        }
                        if (this.lastName) {
                            str += " " + this.lastName;
                        }
                        return str.trim() || this.normal;
                    }
                }, {
                    key: "parse",
                    value: function parse() {
                        var o = parse_name(this.normal);
                        this.honourific = o.honourific;
                        this.firstName = o.firstName;
                        this.middleName = o.middleName;
                        this.lastName = o.lastName;
                    }
                }, {
                    key: "gender",
                    value: function gender() {
                        return guess_gender(this.normal);
                    }
                }, {
                    key: "pronoun",
                    value: function pronoun() {
                        var pronouns = {
                            Male: "he",
                            Female: "she"
                        };
                        var gender = this.gender();
                        return pronouns[gender] || "they";
                    }
                } ]);
                return Person;
            }(Noun);
            Person.fn = Person.prototype;
            module.exports = Person;
        }, {
            "../noun.js": 78,
            "./gender.js": 81,
            "./parse_name.js": 83
        } ],
        85: [ function(require, module, exports) {
            "use strict";
            var places = require("../../../data/places");
            var abbreviations = require("../../../data/abbreviations");
            var isPlace = places.countries.reduce(function(h, s) {
                h[s] = true;
                return h;
            }, {});
            places.cities.forEach(function(s) {
                isPlace[s] = true;
            });
            places.airports.forEach(function(s) {
                isPlace[s] = true;
            });
            abbreviations.places.forEach(function(s) {
                isPlace[s] = true;
            });
            var firstwords = [ "west", "east", "nort", "south", "western", "eastern", "nortern", "southern", "mount" ].reduce(function(h, s) {
                h[s] = true;
                return h;
            }, {});
            var lastwords = [ "city", "town", "county", "village", "province", "country", "state", "province", "mountain", "river", "valley", "park", "avenue", "street", "road" ].reduce(function(h, s) {
                h[s] = true;
                return h;
            }, {});
            var is_place = function is_place(str) {
                var words = str.split(" ");
                if (words.length > 1) {
                    if (firstwords[words[0]]) {
                        return true;
                    }
                    if (lastwords[words[words.length - 1]]) {
                        return true;
                    }
                }
                for (var i = 0; i < words.length; i++) {
                    if (isPlace[words[i]]) {
                        return true;
                    }
                }
                return false;
            };
            module.exports = is_place;
        }, {
            "../../../data/abbreviations": 1,
            "../../../data/places": 19
        } ],
        86: [ function(require, module, exports) {
            "use strict";
            var _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                };
            }();
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            }
            function _possibleConstructorReturn(self, call) {
                if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
            }
            function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var Noun = require("../noun.js");
            var places = require("../../../data/places.js");
            var fns = require("../../../fns.js");
            var countries = fns.toObj(places.countries);
            var cities = fns.toObj(places.cities);
            var Place = function(_Noun) {
                _inherits(Place, _Noun);
                function Place(str, tag) {
                    _classCallCheck(this, Place);
                    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Place).call(this, str));
                    _this.tag = tag;
                    _this.pos["Place"] = true;
                    _this.title = null;
                    _this.city = null;
                    _this.region = null;
                    _this.country = null;
                    _this.parse();
                    return _this;
                }
                _createClass(Place, [ {
                    key: "root",
                    value: function root() {
                        return this.title || this.normal;
                    }
                }, {
                    key: "parse",
                    value: function parse() {
                        var terms = this.strip_apostrophe().split(" ");
                        this.title = terms[0];
                        for (var i = 1; i < terms.length; i++) {
                            var t = terms[i];
                            if (cities[t]) {
                                this.city = fns.titlecase(t);
                            } else if (countries[t]) {
                                this.country = fns.titlecase(t);
                            } else if (this.city !== null) {
                                this.region = fns.titlecase(t);
                            } else {
                                this.title += " " + t;
                            }
                        }
                    }
                } ]);
                return Place;
            }(Noun);
            Place.fn = Place.prototype;
            module.exports = Place;
        }, {
            "../../../data/places.js": 19,
            "../../../fns.js": 23,
            "../noun.js": 78
        } ],
        87: [ function(require, module, exports) {
            "use strict";
            var is_uncountable = require("./is_uncountable.js");
            var irregulars = require("../../data/irregular_nouns.js");
            var is_plural = require("./is_plural.js");
            var fns = require("../../fns.js");
            var pluralize_rules = [ [ /(ax|test)is$/i, "$1es" ], [ /(octop|vir|radi|nucle|fung|cact|stimul)us$/i, "$1i" ], [ /(octop|vir)i$/i, "$1i" ], [ /(kn|l|w)ife$/i, "$1ives" ], [ /^((?:ca|e|ha|(?:our|them|your)?se|she|wo)l|lea|loa|shea|thie)f$/i, "$1ves" ], [ /^(dwar|handkerchie|hoo|scar|whar)f$/i, "$1ves" ], [ /(alias|status)$/i, "$1es" ], [ /(bu)s$/i, "$1ses" ], [ /(al|ad|at|er|et|ed|ad)o$/i, "$1oes" ], [ /([ti])um$/i, "$1a" ], [ /([ti])a$/i, "$1a" ], [ /sis$/i, "ses" ], [ /(hive)$/i, "$1s" ], [ /([^aeiouy]|qu)y$/i, "$1ies" ], [ /(x|ch|ss|sh|s|z)$/i, "$1es" ], [ /(matr|vert|ind|cort)(ix|ex)$/i, "$1ices" ], [ /([m|l])ouse$/i, "$1ice" ], [ /([m|l])ice$/i, "$1ice" ], [ /^(ox)$/i, "$1en" ], [ /^(oxen)$/i, "$1" ], [ /(quiz)$/i, "$1zes" ], [ /(antenn|formul|nebul|vertebr|vit)a$/i, "$1ae" ], [ /(sis)$/i, "ses" ], [ /^(?!talis|.*hu)(.*)man$/i, "$1men" ], [ /(.*)/i, "$1s" ] ].map(function(a) {
                return {
                    reg: a[0],
                    repl: a[1]
                };
            });
            var pluralize = function pluralize(str) {
                var low = str.toLowerCase();
                if (is_uncountable(low)) {
                    return str;
                }
                if (is_plural(low) === true) {
                    return str;
                }
                var found = irregulars.filter(function(r) {
                    return r[0] === low;
                });
                if (found[0]) {
                    if (fns.titlecase(low) === str) {
                        return fns.titlecase(found[0][1]);
                    }
                    return found[0][1];
                }
                if (str.match(/([a-z]*) (of|in|by|for) [a-z]/)) {
                    var first = (str.match(/^([a-z]*) (of|in|by|for) [a-z]/) || [])[1];
                    if (first) {
                        var better_first = pluralize(first);
                        return better_first + str.replace(first, "");
                    }
                }
                for (var i = 0; i < pluralize_rules.length; i++) {
                    if (str.match(pluralize_rules[i].reg)) {
                        return str.replace(pluralize_rules[i].reg, pluralize_rules[i].repl);
                    }
                }
                return null;
            };
            module.exports = pluralize;
        }, {
            "../../data/irregular_nouns.js": 10,
            "../../fns.js": 23,
            "./is_plural.js": 76,
            "./is_uncountable.js": 77
        } ],
        88: [ function(require, module, exports) {
            "use strict";
            var is_person = require("./person/is_person.js");
            var is_plural = require("./is_plural.js");
            var gender = require("./person/gender.js");
            var pronoun = function pronoun(str) {
                if (is_person(str)) {
                    var g = gender(str);
                    if (g === "Male") {
                        return "he";
                    } else if (g === "Female") {
                        return "she";
                    }
                    return "they";
                }
                if (is_plural(str)) {
                    return "they";
                }
                return "it";
            };
            module.exports = pronoun;
        }, {
            "./is_plural.js": 76,
            "./person/gender.js": 81,
            "./person/is_person.js": 82
        } ],
        89: [ function(require, module, exports) {
            "use strict";
            var is_uncountable = require("./is_uncountable.js");
            var irregulars = require("../../data/irregular_nouns.js");
            var is_plural = require("./is_plural.js");
            var fns = require("../../fns.js");
            var singularize_rules = [ [ /([^v])ies$/i, "$1y" ], [ /ises$/i, "isis" ], [ /(kn|[^o]l|w)ives$/i, "$1ife" ], [ /^((?:ca|e|ha|(?:our|them|your)?se|she|wo)l|lea|loa|shea|thie)ves$/i, "$1f" ], [ /^(dwar|handkerchie|hoo|scar|whar)ves$/i, "$1f" ], [ /(antenn|formul|nebul|vertebr|vit)ae$/i, "$1a" ], [ /(octop|vir|radi|nucle|fung|cact|stimul)(i)$/i, "$1us" ], [ /(buffal|tomat|tornad)(oes)$/i, "$1o" ], [ /((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$/i, "$1sis" ], [ /(vert|ind|cort)(ices)$/i, "$1ex" ], [ /(matr|append)(ices)$/i, "$1ix" ], [ /(x|ch|ss|sh|s|z|o)es$/i, "$1" ], [ /men$/i, "man" ], [ /(n)ews$/i, "$1ews" ], [ /([ti])a$/i, "$1um" ], [ /([^aeiouy]|qu)ies$/i, "$1y" ], [ /(s)eries$/i, "$1eries" ], [ /(m)ovies$/i, "$1ovie" ], [ /([m|l])ice$/i, "$1ouse" ], [ /(cris|ax|test)es$/i, "$1is" ], [ /(alias|status)es$/i, "$1" ], [ /(ss)$/i, "$1" ], [ /(ics)$/i, "$1" ], [ /s$/i, "" ] ].map(function(a) {
                return {
                    reg: a[0],
                    repl: a[1]
                };
            });
            var singularize = function singularize(str) {
                var low = str.toLowerCase();
                if (is_uncountable(low)) {
                    return str;
                }
                if (is_plural(low) === false) {
                    return str;
                }
                var found = irregulars.filter(function(r) {
                    return r[1] === low;
                });
                if (found[0]) {
                    if (fns.titlecase(low) === str) {
                        return fns.titlecase(found[0][0]);
                    }
                    return found[0][0];
                }
                if (str.match(/([a-z]*) (of|in|by|for) [a-z]/)) {
                    var first = str.match(/^([a-z]*) (of|in|by|for) [a-z]/);
                    if (first && first[1]) {
                        var better_first = singularize(first[1]);
                        return better_first + str.replace(first[1], "");
                    }
                }
                for (var i = 0; i < singularize_rules.length; i++) {
                    if (str.match(singularize_rules[i].reg)) {
                        return str.replace(singularize_rules[i].reg, singularize_rules[i].repl);
                    }
                }
                return str;
            };
            module.exports = singularize;
        }, {
            "../../data/irregular_nouns.js": 10,
            "../../fns.js": 23,
            "./is_plural.js": 76,
            "./is_uncountable.js": 77
        } ],
        90: [ function(require, module, exports) {
            "use strict";
            var nums = require("../../../data/numbers.js");
            var is_date = require("../date/is_date");
            var is_value = function is_value(str) {
                var words = str.split(" ");
                if (is_date(str)) {
                    return false;
                }
                for (var i = 0; i < words.length; i++) {
                    var w = words[i];
                    if (nums.ones[w] || nums.teens[w] || nums.tens[w] || nums.multiples[w] || nums.prefixes[w]) {
                        return true;
                    }
                    if (parseFloat(w)) {
                        return true;
                    }
                }
                return false;
            };
            module.exports = is_value;
        }, {
            "../../../data/numbers.js": 16,
            "../date/is_date": 74
        } ],
        91: [ function(require, module, exports) {
            "use strict";
            var nums = require("../../../../data/numbers.js");
            var fns = require("../../../../fns");
            var ones = {};
            ones = fns.extend(ones, nums.ones);
            ones = fns.extend(ones, nums.teens);
            ones = fns.extend(ones, nums.ordinal_ones);
            ones = fns.extend(ones, nums.ordinal_teens);
            var decimals = function decimals(words) {
                var str = "0.";
                for (var i = 0; i < words.length; i++) {
                    var w = words[i];
                    if (ones[w]) {
                        str += ones[w];
                    } else {
                        return 0;
                    }
                }
                return parseFloat(str);
            };
            module.exports = decimals;
        }, {
            "../../../../data/numbers.js": 16,
            "../../../../fns": 23
        } ],
        92: [ function(require, module, exports) {
            "use strict";
            var find_modifiers = function find_modifiers(str) {
                var mults = [ {
                    reg: /^(minus|negative)[\s\-]/i,
                    mult: -1
                }, {
                    reg: /^(a\s)?half[\s\-](of\s)?/i,
                    mult: .5
                }, {
                    reg: /^(a\s)?quarter[\s\-]/i,
                    mult: .25
                } ];
                for (var i = 0; i < mults.length; i++) {
                    if (str.match(mults[i].reg)) {
                        return {
                            amount: mults[i].mult,
                            str: str.replace(mults[i].reg, "")
                        };
                    }
                }
                return {
                    amount: 1,
                    str: str
                };
            };
            module.exports = find_modifiers;
        }, {} ],
        93: [ function(require, module, exports) {
            "use strict";
            var nums = require("../../../../data/numbers.js");
            var fns = require("../../../../fns.js");
            var find_modifiers = require("./modifiers.js");
            var parse_decimals = require("./decimals.js");
            var ones = {};
            var teens = {};
            var tens = {};
            var multiples = {};
            ones = fns.extend(ones, nums.ones);
            ones = fns.extend(ones, nums.ordinal_ones);
            teens = fns.extend(teens, nums.teens);
            teens = fns.extend(teens, nums.ordinal_teens);
            tens = fns.extend(tens, nums.tens);
            tens = fns.extend(tens, nums.ordinal_tens);
            multiples = fns.extend(multiples, nums.multiples);
            multiples = fns.extend(multiples, nums.ordinal_multiples);
            var normalize = function normalize(s) {
                s = s.replace(/, ?/g, "");
                s = s.replace(/([a-z])-([a-z])/gi, "$1 $2");
                s = s.replace(/[$£€]/, "");
                s = s.replace(/[\$%\(\)~,]/g, "");
                s = s.trim();
                return s;
            };
            var section_sum = function section_sum(obj) {
                return Object.keys(obj).reduce(function(sum, k) {
                    sum += obj[k];
                    return sum;
                }, 0);
            };
            var appropriate = function appropriate(w, has) {
                if (ones[w]) {
                    if (has.ones || has.teens) {
                        return false;
                    }
                } else if (teens[w]) {
                    if (has.ones || has.teens || has.tens) {
                        return false;
                    }
                } else if (tens[w]) {
                    if (has.ones || has.teens || has.tens) {
                        return false;
                    }
                }
                return true;
            };
            var to_number = function to_number(str) {
                if (!str || typeof str === "number") {
                    return str;
                }
                str = normalize(str);
                var modifier = find_modifiers(str);
                str = modifier.str;
                var biggest_yet = 0;
                var has = {};
                var sum = 0;
                var isNegative = false;
                var words = str.split(" ");
                for (var i = 0; i < words.length; i++) {
                    var w = words[i];
                    if (!w || w === "and") {
                        continue;
                    }
                    if (w === "-" || w === "negative") {
                        isNegative = true;
                        continue;
                    }
                    if (w.startsWith("-")) {
                        isNegative = true;
                        w = w.substr(1);
                    }
                    if (w === "point") {
                        sum += section_sum(has);
                        sum += parse_decimals(words.slice(i + 1, words.length));
                        sum *= modifier.amount;
                        return sum;
                    }
                    if (w.match(/^[0-9,\. ]+$/)) {
                        sum += parseFloat(w.replace(/[, ]/g, "")) || 0;
                        continue;
                    }
                    var improperFractionMatch = w.match(/^([0-9,\. ]+)\/([0-9,\. ]+)$/);
                    if (improperFractionMatch) {
                        var num = parseFloat(improperFractionMatch[1].replace(/[, ]/g, ""));
                        var denom = parseFloat(improperFractionMatch[2].replace(/[, ]/g, ""));
                        sum += num / denom || 0;
                        continue;
                    }
                    if (!appropriate(w, has)) {
                        return null;
                    }
                    if (ones[w]) {
                        has["ones"] = ones[w];
                    } else if (teens[w]) {
                        has["teens"] = teens[w];
                    } else if (tens[w]) {
                        has["tens"] = tens[w];
                    } else if (multiples[w]) {
                        if (multiples[w] === biggest_yet) {
                            return null;
                        }
                        if (multiples[w] > biggest_yet) {
                            biggest_yet = multiples[w];
                            sum += section_sum(has);
                            sum = (sum || 1) * multiples[w];
                        } else {
                            sum += (section_sum(has) || 1) * multiples[w];
                        }
                        has = {};
                    }
                }
                sum += section_sum(has);
                sum *= modifier.amount;
                sum *= isNegative ? -1 : 1;
                return sum;
            };
            module.exports = to_number;
        }, {
            "../../../../data/numbers.js": 16,
            "../../../../fns.js": 23,
            "./decimals.js": 91,
            "./modifiers.js": 92
        } ],
        94: [ function(require, module, exports) {
            "use strict";
            var ones_mapping = [ "", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen" ];
            var tens_mapping = [ [ "ninety", 90 ], [ "eighty", 80 ], [ "seventy", 70 ], [ "sixty", 60 ], [ "fifty", 50 ], [ "forty", 40 ], [ "thirty", 30 ], [ "twenty", 20 ] ];
            var sequence = [ [ 1e9, "million" ], [ 1e8, "hundred million" ], [ 1e6, "million" ], [ 1e5, "hundred thousand" ], [ 1e3, "thousand" ], [ 100, "hundred" ], [ 1, "one" ] ];
            var breakdown_magnitudes = function breakdown_magnitudes(num) {
                var working = num;
                var have = [];
                sequence.forEach(function(a) {
                    if (num > a[0]) {
                        var howmany = Math.floor(working / a[0]);
                        working -= howmany * a[0];
                        if (howmany) {
                            have.push({
                                unit: a[1],
                                count: howmany
                            });
                        }
                    }
                });
                return have;
            };
            var breakdown_hundred = function breakdown_hundred(num) {
                var str = "";
                for (var i = 0; i < tens_mapping.length; i++) {
                    if (num >= tens_mapping[i][1]) {
                        num -= tens_mapping[i][1];
                        str += " " + tens_mapping[i][0];
                    }
                }
                if (ones_mapping[num]) {
                    str += " " + ones_mapping[num];
                }
                return str.trim();
            };
            var to_text = function to_text(num) {
                var isNegative = false;
                if (num < 0) {
                    isNegative = true;
                    num = Math.abs(num);
                }
                var units = breakdown_magnitudes(num);
                var str = "";
                for (var i = 0; i < units.length; i++) {
                    var unit_name = units[i].unit;
                    if (unit_name === "one") {
                        unit_name = "";
                        if (str.length > 1) {
                            str += " and";
                        }
                    }
                    str += " " + breakdown_hundred(units[i].count) + " " + unit_name;
                }
                str = str || "zero";
                str = str.replace(/ +/g, " ");
                str = str.trim();
                if (isNegative) {
                    str = "negative " + str;
                }
                return str;
            };
            module.exports = to_text;
        }, {} ],
        95: [ function(require, module, exports) {
            "use strict";
            var money = require("../../../data/currencies").reduce(function(h, s) {
                h[s] = "currency";
                return h;
            }, {});
            var units = {
                Temperature: {
                    "°c": "Celsius",
                    "°f": "Fahrenheit",
                    k: "Kelvin",
                    "°re": "Reaumur",
                    "°n": "Newton",
                    "°ra": "Rankine"
                },
                Volume: {
                    "m³": "cubic meter",
                    m3: "cubic meter",
                    "dm³": "cubic decimeter",
                    dm3: "cubic decimeter",
                    "cm³": "cubic centimeter",
                    cm3: "cubic centimeter",
                    l: "liter",
                    dl: "deciliter",
                    cl: "centiliter",
                    ml: "milliliter",
                    "in³": "cubic inch",
                    in3: "cubic inch",
                    "ft³": "cubic foot",
                    ft3: "cubic foot",
                    "yd³": "cubic yard",
                    yd3: "cubic yard",
                    gal: "gallon",
                    bbl: "petroleum barrel",
                    pt: "pint",
                    qt: "quart",
                    tbl: "tablespoon",
                    tsp: "teaspoon",
                    tbsp: "tablespoon",
                    cp: "cup",
                    "fl oz": "fluid ounce"
                },
                Distance: {
                    km: "kilometer",
                    m: "meter",
                    dm: "decimeter",
                    cm: "centimeter",
                    mm: "millimeter",
                    mi: "mile",
                    "in": "inch",
                    ft: "foot",
                    feet: "foot",
                    yd: "yard"
                },
                Weight: {
                    t: "tonne",
                    kg: "kilogram",
                    hg: "hectogram",
                    g: "gram",
                    dg: "decigram",
                    cg: "centigram",
                    mg: "milligram",
                    "µg": "microgram",
                    carat: "carat",
                    grain: "grain",
                    oz: "ounce",
                    lb: "pound",
                    ton: "tonne",
                    st: "stone"
                },
                Area: {
                    "km²": "square kilometer",
                    km2: "square kilometer",
                    "m²": "square meter",
                    m2: "square meter",
                    "dm²": "square decimeter",
                    dm2: "square decimeter",
                    "cm²": "square centimeter",
                    cm2: "square centimeter",
                    "mm²": "square millimeter",
                    mm2: "square millimeter",
                    ha: "hectare",
                    ca: "centiare",
                    "mile²": "square mile",
                    mile2: "square mile",
                    "in²": "square inch",
                    in2: "square inch",
                    "yd²": "square yard",
                    yd2: "square yard",
                    "ft²": "square foot",
                    ft2: "square foot",
                    acre: "acre"
                },
                Frequency: {
                    hz: "hertz"
                },
                Speed: {
                    "km/h": "kilometer per hour",
                    kmph: "kilometer per hour",
                    mps: "meter per second",
                    "m/s": "meter per second",
                    mph: "mile per hour",
                    "mi/h": "mile per hour",
                    knot: "knot"
                },
                Data: {
                    b: "byte",
                    kb: "kilobyte",
                    mb: "megabyte",
                    gb: "gigabyte",
                    tb: "terabyte",
                    pt: "petabyte",
                    eb: "exabyte",
                    zb: "zettabyte",
                    yb: "yottabyte"
                },
                Energy: {
                    j: "joule",
                    pa: "pascal",
                    bar: "bar",
                    w: "watt",
                    n: "newton",
                    wb: "weber",
                    t: "tesla",
                    h: "henry",
                    c: "coulomb",
                    v: "volt",
                    f: "farad",
                    s: "siemens",
                    o: "ohm",
                    lx: "lux",
                    lm: "lumen"
                },
                Time: {
                    year: "year",
                    week: "week",
                    day: "day",
                    h: "hour",
                    min: "minute",
                    s: "second",
                    ms: "millisecond",
                    "µs": "microsecond",
                    nanosecond: "nanosecond",
                    picosecond: "picosecond",
                    femtosecond: "femtosecond",
                    attosecond: "attosecond"
                },
                Money: money
            };
            module.exports = Object.keys(units).reduce(function(h, k) {
                Object.keys(units[k]).forEach(function(u) {
                    h[u] = {
                        name: units[k][u],
                        category: k
                    };
                    h[units[k][u]] = {
                        name: units[k][u],
                        category: k
                    };
                });
                return h;
            }, {});
        }, {
            "../../../data/currencies": 4
        } ],
        96: [ function(require, module, exports) {
            "use strict";
            var _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                };
            }();
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            }
            function _possibleConstructorReturn(self, call) {
                if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
            }
            function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var Noun = require("../noun");
            var to_number = require("./parse/to_number");
            var to_text = require("./to_text");
            var units = require("./units");
            var nums = require("../../../data/numbers");
            var fns = require("../../../fns");
            var ordinals = {};
            ordinals = fns.extend(ordinals, nums.ordinal_ones);
            ordinals = fns.extend(ordinals, nums.ordinal_teens);
            ordinals = fns.extend(ordinals, nums.ordinal_tens);
            ordinals = fns.extend(ordinals, nums.ordinal_multiples);
            ordinals = Object.keys(ordinals);
            var Value = function(_Noun) {
                _inherits(Value, _Noun);
                function Value(str, tag) {
                    _classCallCheck(this, Value);
                    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Value).call(this, str));
                    _this.tag = tag;
                    _this.pos["Value"] = true;
                    _this.number = null;
                    _this.unit = null;
                    _this.unit_name = null;
                    _this.measurement = null;
                    _this.of_what = "";
                    if (_this.is_ordinal()) {
                        _this.pos["Ordinal"] = true;
                    }
                    _this.parse();
                    return _this;
                }
                _createClass(Value, [ {
                    key: "is_number",
                    value: function is_number(s) {
                        if (s.match(/[:@]/)) {
                            return false;
                        }
                        if (s.match(/[0-9][^(0-9|\/),\.][0-9]/)) {
                            if (s.match(/((?:[0-9]|\.)+) ((?:[0-9]|\.)+)\/((?:[0-9]|\.)+)/)) {
                                return true;
                            }
                            return false;
                        }
                        return true;
                    }
                }, {
                    key: "is_number_word",
                    value: function is_number_word(w) {
                        var number_words = {
                            minus: true,
                            negative: true,
                            point: true,
                            half: true,
                            quarter: true
                        };
                        if (w.match(/[0-9]/) || number_words[w]) {
                            return true;
                        } else if (nums.ones[w] || nums.teens[w] || nums.tens[w] || nums.multiples[w]) {
                            return true;
                        } else if (nums.ordinal_ones[w] || nums.ordinal_teens[w] || nums.ordinal_tens[w] || nums.ordinal_multiples[w]) {
                            return true;
                        }
                        return false;
                    }
                }, {
                    key: "is_ordinal",
                    value: function is_ordinal() {
                        if (this.normal.match(/^[0-9]+(rd|st|nd|th)$/)) {
                            return true;
                        }
                        for (var i = 0; i < ordinals.length; i++) {
                            if (fns.endsWith(this.normal, ordinals[i])) {
                                return true;
                            }
                        }
                        return false;
                    }
                }, {
                    key: "to_ordinal",
                    value: function to_ordinal() {
                        var num = this.number;
                        if (!num && num !== 0) {
                            return "";
                        }
                        if (num >= 10 && num <= 20) {
                            return "" + num + "th";
                        }
                        num = "" + num;
                        if (!num.match(/[0-9]$/)) {
                            return num;
                        }
                        if (fns.endsWith(num, "1")) {
                            return num + "st";
                        }
                        if (fns.endsWith(num, "2")) {
                            return num + "nd";
                        }
                        if (fns.endsWith(num, "3")) {
                            return num + "rd";
                        }
                        return num + "th";
                    }
                }, {
                    key: "root",
                    value: function root() {
                        var str = this.number;
                        if (this.unit) {
                            str += " " + this.unit;
                        }
                        return str;
                    }
                }, {
                    key: "is_unit",
                    value: function is_unit() {
                        if (units[this.unit]) {
                            return true;
                        }
                        if (this.pos["Currency"]) {
                            return true;
                        }
                        var s = this.unit.toLowerCase();
                        if (nums.prefixes[s]) {
                            return true;
                        }
                        s = this.unit.replace(/s$/, "");
                        if (units[s]) {
                            this.unit = this.unit.replace(/s$/, "");
                            return true;
                        }
                        s = this.unit.replace(/es$/, "");
                        if (units[s]) {
                            this.unit = this.unit.replace(/es$/, "");
                            return true;
                        }
                        return false;
                    }
                }, {
                    key: "parse",
                    value: function parse() {
                        if (!this.is_number(this.text)) {
                            return;
                        }
                        var words = this.text.toLowerCase().split(/[ ]/);
                        for (var i = 0; i < words.length; i++) {
                            var w = words[i];
                            if (w.indexOf("-") === w.lastIndexOf("-") && w.indexOf("-") > -1) {
                                var halves = w.split(/[-]/);
                                if (this.is_number_word(halves[0]) && this.is_number_word(halves[1])) {
                                    words[i] = halves[0];
                                    words.splice(i + 1, 0, halves[1]);
                                }
                            }
                        }
                        var numbers = "";
                        var raw_units = "";
                        for (var i = 0; i < words.length; i++) {
                            var w = words[i];
                            if (this.is_number_word(w)) {
                                numbers += " " + w;
                            } else {
                                raw_units += " " + w;
                            }
                        }
                        this.unit = raw_units.trim();
                        while (this.unit !== "") {
                            if (this.is_unit() && units[this.unit]) {
                                this.measurement = units[this.unit].category;
                                this.unit_name = units[this.unit].name;
                                break;
                            } else {
                                this.unit = this.unit.substr(0, this.unit.lastIndexOf(" ")).trim();
                            }
                        }
                        var firstChar = this.text.substr(0, 1);
                        var symbolic_currency = {
                            "€": "euro",
                            $: "dollar",
                            "¥": "yen",
                            "£": "pound",
                            "¢": "cent",
                            "฿": "bitcoin"
                        };
                        if (symbolic_currency[firstChar]) {
                            this.measurement = "Money";
                            this.unit_name = "currency";
                            this.unit = symbolic_currency[firstChar];
                        }
                        numbers = numbers.trim();
                        this.number = to_number(numbers);
                        var of_pos = this.text.indexOf(" of ");
                        if (of_pos > 0) {
                            this.of_what = this.text.substring(of_pos + 4).trim();
                        } else if (this.unit_name) {
                            this.of_what = this.unit_name;
                        }
                    }
                }, {
                    key: "textual",
                    value: function textual() {
                        return to_text(this.number || this.normal || this.text);
                    }
                } ]);
                return Value;
            }(Noun);
            Value.fn = Value.prototype;
            module.exports = Value;
        }, {
            "../../../data/numbers": 16,
            "../../../fns": 23,
            "../noun": 78,
            "./parse/to_number": 93,
            "./to_text": 94,
            "./units": 95
        } ],
        97: [ function(require, module, exports) {
            "use strict";
            var _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                };
            }();
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            }
            var _is_acronym = require("./is_acronym");
            var match_term = require("../match/match_term");
            var syntax_parse = require("../match/syntax_parse");
            var implied = require("./implied");
            var Term = function() {
                function Term(str, tag, whitespace) {
                    _classCallCheck(this, Term);
                    if (typeof str === "number") {
                        str = "" + str;
                    } else if (typeof str !== "string") {
                        str = "";
                    }
                    str = str.toString();
                    this.whitespace = whitespace || {};
                    this.whitespace.preceding = this.whitespace.preceding || "";
                    this.whitespace.trailing = this.whitespace.trailing || "";
                    this.text = str;
                    this.normal = "";
                    this.expansion = "";
                    this.rebuild();
                    this.reason = "";
                    var types = {
                        Determiner: "Determiner",
                        Conjunction: "Conjunction",
                        Preposition: "Preposition",
                        Possessive: "Possessive",
                        Expression: "Expression",
                        Condition: "Condition"
                    };
                    this.pos = {};
                    this.tag = types[tag] || "?";
                    if (types[tag]) {
                        this.pos[types[tag]] = true;
                    }
                }
                _createClass(Term, [ {
                    key: "rebuild",
                    value: function rebuild() {
                        this.text = this.text || "";
                        this.text = this.text.trim();
                        this.normal = "";
                        this.normalize();
                        this.expansion = implied(this.normal);
                    }
                }, {
                    key: "changeTo",
                    value: function changeTo(str) {
                        this.text = str;
                        this.rebuild();
                    }
                }, {
                    key: "match",
                    value: function match(match_str, options) {
                        var reg = syntax_parse([ match_str ]);
                        return match_term(this, reg[0], options);
                    }
                }, {
                    key: "root",
                    value: function root() {
                        return this.strip_apostrophe();
                    }
                }, {
                    key: "strip_apostrophe",
                    value: function strip_apostrophe() {
                        if (this.normal.match(/[a-z]'[a-z][a-z]?$/)) {
                            var split = this.normal.split(/'/);
                            if (split[1] === "s") {
                                return split[0];
                            }
                        }
                        return this.normal;
                    }
                }, {
                    key: "has_comma",
                    value: function has_comma() {
                        if (this.text.match(/,$/)) {
                            return true;
                        }
                        return false;
                    }
                }, {
                    key: "has_abbreviation",
                    value: function has_abbreviation() {
                        if (this.text.match(/[a-z]'[a-z][a-z]?$/)) {
                            return true;
                        }
                        if (this.text.match(/[a-z]s'$/)) {
                            return true;
                        }
                        return false;
                    }
                }, {
                    key: "is_capital",
                    value: function is_capital() {
                        if (this.text.match(/[A-Z][a-z]/)) {
                            return true;
                        }
                        return false;
                    }
                }, {
                    key: "is_word",
                    value: function is_word() {
                        if (this.text.match(/^\[.*?\]\??$/)) {
                            return false;
                        }
                        if (!this.text.match(/[a-z|0-9]/i)) {
                            return false;
                        }
                        if (this.text.match(/[\|#\<\>]/i)) {
                            return false;
                        }
                        return true;
                    }
                }, {
                    key: "is_acronym",
                    value: function is_acronym() {
                        return _is_acronym(this.text);
                    }
                }, {
                    key: "normalize",
                    value: function normalize() {
                        var str = this.text || "";
                        str = str.toLowerCase();
                        str = str.replace(/[,\.!:;\?\(\)^$]/g, "");
                        str = str.replace(/([a-z])\-([a-z])/g, "$1 $2");
                        str = str.replace(/[\u2018\u2019\u201A\u201B\u2032\u2035]+/g, "'");
                        str = str.replace(/[\u201C\u201D\u201E\u201F\u2033\u2036]+/g, "");
                        str = str.replace(/^'/g, "");
                        str = str.replace(/'$/g, "");
                        str = str.replace(/"/g, "");
                        if (!str.match(/[a-z0-9]/i)) {
                            return "";
                        }
                        this.normal = str;
                        return this.normal;
                    }
                }, {
                    key: "forms",
                    value: function forms() {
                        if (this.pos["Noun"]) {
                            return {
                                singular: this.singularize(),
                                plural: this.pluralize()
                            };
                        } else if (this.pos["Verb"] || this.pos["Adjective"]) {
                            return this.conjugate();
                        } else if (this.pos["Adverb"]) {
                            return {
                                adjective: this.to_adjective()
                            };
                        }
                        return {};
                    }
                } ]);
                return Term;
            }();
            Term.fn = Term.prototype;
            module.exports = Term;
        }, {
            "../match/match_term": 27,
            "../match/syntax_parse": 29,
            "./implied": 69,
            "./is_acronym": 70
        } ],
        98: [ function(require, module, exports) {
            "use strict";
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
            };
            var verb_to_actor = require("./to_actor");
            var to_infinitive = require("./to_infinitive");
            var from_infinitive = require("./from_infinitive");
            var irregular_verbs = require("../../../data/irregular_verbs");
            var predict = require("./predict_form.js");
            var generic = require("./generic.js");
            var strip_prefix = require("./strip_prefix.js");
            var fns = require("../../../fns.js");
            var fufill = function fufill(obj, prefix) {
                if (!obj.infinitive) {
                    return obj;
                }
                if (!obj.gerund) {
                    obj.gerund = generic.gerund(obj);
                }
                if (!obj.present) {
                    obj.present = generic.present(obj);
                }
                if (!obj.past) {
                    obj.past = generic.past(obj);
                }
                if (obj.actor === undefined) {
                    obj.actor = verb_to_actor(obj.infinitive);
                }
                if (prefix) {
                    Object.keys(obj).forEach(function(k) {
                        obj[k] = prefix + obj[k];
                    });
                }
                if (!obj.future) {
                    obj.future = generic.future(obj);
                }
                if (!obj.perfect) {
                    obj.perfect = generic.perfect(obj);
                }
                if (!obj.pluperfect) {
                    obj.pluperfect = generic.pluperfect(obj);
                }
                if (!obj.future_perfect) {
                    obj.future_perfect = generic.future_perfect(obj);
                }
                return obj;
            };
            var conjugate = function conjugate(w) {
                if (w === undefined) {
                    return {};
                }
                var phrasal_reg = new RegExp("^(.*?) (in|out|on|off|behind|way|with|of|away|across|ahead|back|over|under|together|apart|up|upon|aback|down|about|before|after|around|to|forth|round|through|along|onto)$", "i");
                if (w.match(phrasal_reg)) {
                    var _ret = function() {
                        var split = w.match(phrasal_reg, "");
                        var phrasal_verb = split[1];
                        var particle = split[2];
                        var result = conjugate(phrasal_verb);
                        Object.keys(result).forEach(function(k) {
                            if (result[k]) {
                                result[k] += " " + particle;
                            }
                        });
                        return {
                            v: result
                        };
                    }();
                    if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
                }
                w = w.replace(/^had /i, "");
                w = w.replace(/^have /i, "");
                w = w.replace(/^will have /i, "");
                w = w.replace(/^will /i, "");
                var prefix = strip_prefix(w);
                w = w.replace(prefix, "");
                var predicted = predict(w) || "infinitive";
                var infinitive = to_infinitive(w, predicted) || "";
                var obj = irregular_verbs[w] || irregular_verbs[infinitive] || {};
                obj = fns.extend({}, obj);
                var conjugations = from_infinitive(infinitive);
                Object.keys(conjugations).forEach(function(k) {
                    if (!obj[k]) {
                        obj[k] = conjugations[k];
                    }
                });
                return fufill(obj, prefix);
            };
            module.exports = conjugate;
        }, {
            "../../../data/irregular_verbs": 11,
            "../../../fns.js": 23,
            "./from_infinitive": 99,
            "./generic.js": 100,
            "./predict_form.js": 101,
            "./strip_prefix.js": 102,
            "./to_actor": 104,
            "./to_infinitive": 105
        } ],
        99: [ function(require, module, exports) {
            "use strict";
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
            };
            var rules = [ {
                reg: /(eave)$/i,
                repl: {
                    pr: "$1s",
                    pa: "$1d",
                    gr: "eaving",
                    ar: "$1r"
                }
            }, {
                reg: /(ink)$/i,
                repl: {
                    pr: "$1s",
                    pa: "unk",
                    gr: "$1ing",
                    ar: "$1er"
                }
            }, {
                reg: /(end)$/i,
                repl: {
                    pr: "$1s",
                    pa: "ent",
                    gr: "$1ing",
                    ar: "$1er"
                }
            }, {
                reg: /(ide)$/i,
                repl: {
                    pr: "$1s",
                    pa: "ode",
                    gr: "iding",
                    ar: "ider"
                }
            }, {
                reg: /(ake)$/i,
                repl: {
                    pr: "$1s",
                    pa: "ook",
                    gr: "aking",
                    ar: "$1r"
                }
            }, {
                reg: /(eed)$/i,
                repl: {
                    pr: "$1s",
                    pa: "$1ed",
                    gr: "$1ing",
                    ar: "$1er"
                }
            }, {
                reg: /(e)(ep)$/i,
                repl: {
                    pr: "$1$2s",
                    pa: "$1pt",
                    gr: "$1$2ing",
                    ar: "$1$2er"
                }
            }, {
                reg: /(a[tg]|i[zn]|ur|nc|gl|is)e$/i,
                repl: {
                    pr: "$1es",
                    pa: "$1ed",
                    gr: "$1ing",
                    prt: "$1en"
                }
            }, {
                reg: /([i|f|rr])y$/i,
                repl: {
                    pr: "$1ies",
                    pa: "$1ied",
                    gr: "$1ying"
                }
            }, {
                reg: /([td]er)$/i,
                repl: {
                    pr: "$1s",
                    pa: "$1ed",
                    gr: "$1ing"
                }
            }, {
                reg: /([bd]l)e$/i,
                repl: {
                    pr: "$1es",
                    pa: "$1ed",
                    gr: "$1ing"
                }
            }, {
                reg: /(ish|tch|ess)$/i,
                repl: {
                    pr: "$1es",
                    pa: "$1ed",
                    gr: "$1ing"
                }
            }, {
                reg: /(ion|end|e[nc]t)$/i,
                repl: {
                    pr: "$1s",
                    pa: "$1ed",
                    gr: "$1ing"
                }
            }, {
                reg: /(om)e$/i,
                repl: {
                    pr: "$1es",
                    pa: "ame",
                    gr: "$1ing"
                }
            }, {
                reg: /([aeiu])([pt])$/i,
                repl: {
                    pr: "$1$2s",
                    pa: "$1$2",
                    gr: "$1$2$2ing"
                }
            }, {
                reg: /(er)$/i,
                repl: {
                    pr: "$1s",
                    pa: "$1ed",
                    gr: "$1ing"
                }
            }, {
                reg: /(en)$/i,
                repl: {
                    pr: "$1s",
                    pa: "$1ed",
                    gr: "$1ing"
                }
            }, {
                reg: /(..)(ow)$/i,
                repl: {
                    pr: "$1$2s",
                    pa: "$1ew",
                    gr: "$1$2ing",
                    prt: "$1$2n"
                }
            }, {
                reg: /(..)([cs]h)$/i,
                repl: {
                    pr: "$1$2es",
                    pa: "$1$2ed",
                    gr: "$1$2ing"
                }
            }, {
                reg: /([^aeiou][ou])(g|d)$/i,
                repl: {
                    pr: "$1$2s",
                    pa: "$1$2$2ed",
                    gr: "$1$2$2ing"
                }
            }, {
                reg: /([^aeiou][aeiou])(b|t|p|m)$/i,
                repl: {
                    pr: "$1$2s",
                    pa: "$1$2$2ed",
                    gr: "$1$2$2ing"
                }
            } ];
            var keys = {
                pr: "present",
                pa: "past",
                gr: "gerund",
                prt: "participle",
                ar: "actor"
            };
            var from_infinitive = function from_infinitive(str) {
                var obj = {
                    infinitive: str
                };
                if (!str || typeof str !== "string") {
                    return obj;
                }
                var _loop = function _loop(i) {
                    if (str.match(rules[i].reg)) {
                        Object.keys(rules[i].repl).forEach(function(k) {
                            obj[keys[k]] = str.replace(rules[i].reg, rules[i].repl[k]);
                        });
                        return {
                            v: obj
                        };
                    }
                };
                for (var i = 0; i < rules.length; i++) {
                    var _ret = _loop(i);
                    if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
                }
                return obj;
            };
            module.exports = from_infinitive;
        }, {} ],
        100: [ function(require, module, exports) {
            "use strict";
            var fns = require("../../../fns");
            var generic = {
                gerund: function gerund(o) {
                    var inf = o.infinitive;
                    if (fns.endsWith(inf, "e")) {
                        return inf.replace(/e$/, "ing");
                    }
                    return inf + "ing";
                },
                present: function present(o) {
                    var inf = o.infinitive;
                    if (fns.endsWith(inf, "s")) {
                        return inf + "es";
                    }
                    return inf + "s";
                },
                past: function past(o) {
                    var inf = o.infinitive;
                    if (fns.endsWith(inf, "e")) {
                        return inf + "d";
                    }
                    if (fns.endsWith(inf, "ed")) {
                        return inf;
                    }
                    return inf + "ed";
                },
                future: function future(o) {
                    return "will " + o.infinitive;
                },
                perfect: function perfect(o) {
                    return "have " + (o.participle || o.past);
                },
                pluperfect: function pluperfect(o) {
                    return "had " + o.past;
                },
                future_perfect: function future_perfect(o) {
                    return "will have " + o.past;
                }
            };
            module.exports = generic;
        }, {
            "../../../fns": 23
        } ],
        101: [ function(require, module, exports) {
            "use strict";
            var fns = require("../../../fns.js");
            var suffix_rules = require("./suffix_rules");
            var irregular_verbs = require("../../../data/irregular_verbs");
            var known_verbs = Object.keys(irregular_verbs).reduce(function(h, k) {
                Object.keys(irregular_verbs[k]).forEach(function(k2) {
                    h[irregular_verbs[k][k2]] = k2;
                });
                return h;
            }, {});
            var predict = function predict(w) {
                if (irregular_verbs[w]) {
                    return "infinitive";
                }
                if (known_verbs[w]) {
                    return known_verbs[w];
                }
                if (w.match(/will ha(ve|d) [a-z]{2}/)) {
                    return "future_perfect";
                }
                if (w.match(/will [a-z]{2}/)) {
                    return "future";
                }
                if (w.match(/had [a-z]{2}/)) {
                    return "pluperfect";
                }
                if (w.match(/have [a-z]{2}/)) {
                    return "perfect";
                }
                if (w.match(/..erer$/)) {
                    return "actor";
                }
                if (w.match(/[^aeiou]ing$/)) {
                    return "gerund";
                }
                var arr = Object.keys(suffix_rules);
                for (var i = 0; i < arr.length; i++) {
                    if (fns.endsWith(w, arr[i]) && arr[i].length < w.length) {
                        return suffix_rules[arr[i]];
                    }
                }
                return "infinitive";
            };
            module.exports = predict;
        }, {
            "../../../data/irregular_verbs": 11,
            "../../../fns.js": 23,
            "./suffix_rules": 103
        } ],
        102: [ function(require, module, exports) {
            "use strict";
            var strip_prefix = function strip_prefix(str) {
                var prefix = "";
                var match = str.match(/^(over|under|re|anti|full|cross)([- ])?([^aeiou][a-z]*)/i);
                if (match) {
                    prefix = match[1] + (match[2] || "");
                }
                return prefix;
            };
            module.exports = strip_prefix;
        }, {} ],
        103: [ function(require, module, exports) {
            "use strict";
            var compact = {
                gerund: [ "ing" ],
                infinitive: [ "ate", "ize", "tion", "rify", "then", "ress", "ify", "age", "nce", "ect", "ise", "ine", "ish", "ace", "ash", "ure", "tch", "end", "ack", "and", "ute", "ade", "ock", "ite", "ase", "ose", "use", "ive", "int", "nge", "lay", "est", "ain", "ant", "eed", "er", "le" ],
                participle: [ "own", "unk", "ung", "en" ],
                past: [ "ed", "lt", "nt", "pt", "ew", "ld" ],
                present: [ "rks", "cks", "nks", "ngs", "mps", "tes", "zes", "ers", "les", "acks", "ends", "ands", "ocks", "lays", "eads", "lls", "els", "ils", "ows", "nds", "ays", "ams", "ars", "ops", "ffs", "als", "urs", "lds", "ews", "ips", "es", "ts", "ns", "s" ]
            };
            var suffix_rules = {};
            var keys = Object.keys(compact);
            var l = keys.length;
            for (var i = 0; i < l; i++) {
                var l2 = compact[keys[i]].length;
                for (var o = 0; o < l2; o++) {
                    suffix_rules[compact[keys[i]][o]] = keys[i];
                }
            }
            module.exports = suffix_rules;
        }, {} ],
        104: [ function(require, module, exports) {
            "use strict";
            var actor = function actor(str) {
                str = str || "";
                var irregulars = {
                    tie: "tier",
                    dream: "dreamer",
                    sail: "sailer",
                    run: "runner",
                    rub: "rubber",
                    begin: "beginner",
                    win: "winner",
                    claim: "claimant",
                    deal: "dealer",
                    spin: "spinner"
                };
                var dont = {
                    aid: 1,
                    fail: 1,
                    appear: 1,
                    happen: 1,
                    seem: 1,
                    "try": 1,
                    say: 1,
                    marry: 1,
                    be: 1,
                    forbid: 1,
                    understand: 1,
                    bet: 1
                };
                var transforms = [ {
                    reg: /e$/i,
                    repl: "er"
                }, {
                    reg: /([aeiou])([mlgp])$/i,
                    repl: "$1$2$2er"
                }, {
                    reg: /([rlf])y$/i,
                    repl: "$1ier"
                }, {
                    reg: /^(.?.[aeiou])t$/i,
                    repl: "$1tter"
                } ];
                if (dont.hasOwnProperty(str)) {
                    return null;
                }
                if (irregulars.hasOwnProperty(str)) {
                    return irregulars[str];
                }
                for (var i = 0; i < transforms.length; i++) {
                    if (str.match(transforms[i].reg)) {
                        return str.replace(transforms[i].reg, transforms[i].repl);
                    }
                }
                return str + "er";
            };
            module.exports = actor;
        }, {} ],
        105: [ function(require, module, exports) {
            "use strict";
            var irregular_verbs = require("../../../data/irregular_verbs");
            var known_verbs = Object.keys(irregular_verbs).reduce(function(h, k) {
                Object.keys(irregular_verbs[k]).forEach(function(k2) {
                    h[irregular_verbs[k][k2]] = k;
                });
                return h;
            }, {});
            var rules = {
                participle: [ {
                    reg: /own$/i,
                    to: "ow"
                }, {
                    reg: /(.)un([g|k])$/i,
                    to: "$1in$2"
                } ],
                actor: [ {
                    reg: /(er)er$/i,
                    to: "$1"
                } ],
                present: [ {
                    reg: /(ies)$/i,
                    to: "y"
                }, {
                    reg: /(tch|sh)es$/i,
                    to: "$1"
                }, {
                    reg: /(ss)es$/i,
                    to: "$1"
                }, {
                    reg: /([tzlshicgrvdnkmu])es$/i,
                    to: "$1e"
                }, {
                    reg: /(n[dtk]|c[kt]|[eo]n|i[nl]|er|a[ytrl])s$/i,
                    to: "$1"
                }, {
                    reg: /(ow)s$/i,
                    to: "$1"
                }, {
                    reg: /(op)s$/i,
                    to: "$1"
                }, {
                    reg: /([eirs])ts$/i,
                    to: "$1t"
                }, {
                    reg: /(ll)s$/i,
                    to: "$1"
                }, {
                    reg: /(el)s$/i,
                    to: "$1"
                }, {
                    reg: /(ip)es$/i,
                    to: "$1e"
                }, {
                    reg: /ss$/i,
                    to: "ss"
                }, {
                    reg: /s$/i,
                    to: ""
                } ],
                gerund: [ {
                    reg: /pping$/i,
                    to: "p"
                }, {
                    reg: /lling$/i,
                    to: "ll"
                }, {
                    reg: /tting$/i,
                    to: "t"
                }, {
                    reg: /ssing$/i,
                    to: "ss"
                }, {
                    reg: /gging$/i,
                    to: "g"
                }, {
                    reg: /([^aeiou])ying$/i,
                    to: "$1y"
                }, {
                    reg: /(i.)ing$/i,
                    to: "$1e"
                }, {
                    reg: /(u[rtcb]|[bdtpkg]l|n[cg]|a[gdkvtc]|[ua]s|[dr]g|yz|o[rlsp]|cre)ing$/i,
                    to: "$1e"
                }, {
                    reg: /(ch|sh)ing$/i,
                    to: "$1"
                }, {
                    reg: /(..)ing$/i,
                    to: "$1"
                } ],
                past: [ {
                    reg: /(ued)$/i,
                    to: "ue"
                }, {
                    reg: /(e|i)lled$/i,
                    to: "$1ll"
                }, {
                    reg: /(sh|ch)ed$/i,
                    to: "$1"
                }, {
                    reg: /(tl|gl)ed$/i,
                    to: "$1e"
                }, {
                    reg: /(um?pt?)ed$/i,
                    to: "$1"
                }, {
                    reg: /(ss)ed$/i,
                    to: "$1"
                }, {
                    reg: /pped$/i,
                    to: "p"
                }, {
                    reg: /tted$/i,
                    to: "t"
                }, {
                    reg: /gged$/i,
                    to: "g"
                }, {
                    reg: /(h|ion|n[dt]|ai.|[cs]t|pp|all|ss|tt|int|ail|ld|en|oo.|er|k|pp|w|ou.|rt|ght|rm)ed$/i,
                    to: "$1"
                }, {
                    reg: /(.ut)ed$/i,
                    to: "$1e"
                }, {
                    reg: /(us)ed$/i,
                    to: "$1e"
                }, {
                    reg: /(..[^aeiou])ed$/i,
                    to: "$1e"
                }, {
                    reg: /ied$/i,
                    to: "y"
                }, {
                    reg: /(.o)ed$/i,
                    to: "$1o"
                }, {
                    reg: /(.i)ed$/i,
                    to: "$1"
                }, {
                    reg: /([rl])ew$/i,
                    to: "$1ow"
                }, {
                    reg: /([pl])t$/i,
                    to: "$1t"
                } ]
            };
            var to_infinitive = function to_infinitive(str, from_tense) {
                if (known_verbs.hasOwnProperty(str)) {
                    return known_verbs[str];
                }
                if (from_tense === "infinitive") {
                    return str;
                }
                var regs = rules[from_tense] || [];
                for (var i = 0; i < regs.length; i++) {
                    if (str.match(regs[i].reg)) {
                        return str.replace(regs[i].reg, regs[i].to);
                    }
                }
                return str;
            };
            module.exports = to_infinitive;
        }, {
            "../../../data/irregular_verbs": 11
        } ],
        106: [ function(require, module, exports) {
            "use strict";
            var rules = [ [ /y$/, "i" ], [ /([aeiou][n])$/, "$1n" ] ];
            var ible_suffixes = {
                collect: true,
                exhaust: true,
                convert: true,
                digest: true,
                discern: true,
                dismiss: true,
                reverse: true,
                access: true,
                collapse: true,
                express: true
            };
            var irregulars = {
                eat: "edible",
                hear: "audible",
                see: "visible",
                defend: "defensible",
                write: "legible",
                move: "movable",
                divide: "divisible",
                perceive: "perceptible"
            };
            var to_adjective = function to_adjective(str) {
                if (irregulars[str]) {
                    return irregulars[str];
                }
                for (var i = 0; i < rules.length; i++) {
                    if (str.match(rules[i][0])) {
                        str = str.replace(rules[i][0], rules[i][1]);
                    }
                }
                var adj = str + "able";
                if (ible_suffixes[str]) {
                    adj = str + "ible";
                }
                return adj;
            };
            module.exports = to_adjective;
        }, {} ],
        107: [ function(require, module, exports) {
            "use strict";
            var _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                };
            }();
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            }
            function _possibleConstructorReturn(self, call) {
                if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
            }
            function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            }
            var Term = require("../term.js");
            var _conjugate = require("./conjugate/conjugate.js");
            var _negate = require("./verb_negate.js");
            var _to_adjective = require("./to_adjective.js");
            var predict_form = require("./conjugate/predict_form.js");
            var verbTags = {
                infinitive: "Infinitive",
                present: "PresentTense",
                past: "PastTense",
                gerund: "Gerund",
                actor: "Actor",
                future: "FutureTense",
                pluperfect: "PluperfectTense",
                perfect: "PerfectTense"
            };
            var Verb = function(_Term) {
                _inherits(Verb, _Term);
                function Verb(str, tag) {
                    _classCallCheck(this, Verb);
                    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Verb).call(this, str));
                    _this.tag = tag;
                    _this.pos["Verb"] = true;
                    if (tag) {
                        _this.pos[tag] = true;
                    }
                    return _this;
                }
                _createClass(Verb, [ {
                    key: "root",
                    value: function root() {
                        return this.conjugate().infinitive;
                    }
                }, {
                    key: "conjugation",
                    value: function conjugation() {
                        var conjugations = this.conjugate();
                        var keys = Object.keys(conjugations);
                        for (var i = 0; i < keys.length; i++) {
                            if (conjugations[keys[i]] === this.normal) {
                                return verbTags[keys[i]];
                            }
                        }
                        return verbTags[predict_form(this.normal)];
                    }
                }, {
                    key: "tense",
                    value: function tense() {
                        var tenses = {
                            infinitive: "present",
                            gerund: "present",
                            actor: "present",
                            present: "present",
                            past: "past",
                            future: "future",
                            perfect: "past",
                            pluperfect: "past",
                            future_perfect: "future"
                        };
                        var c = this.conjugation();
                        return tenses[c] || "present";
                    }
                }, {
                    key: "conjugate",
                    value: function conjugate() {
                        return _conjugate(this.normal);
                    }
                }, {
                    key: "to_past",
                    value: function to_past() {
                        var tense = "past";
                        var conjugations = this.conjugate(this.normal);
                        this.tag = verbTags[tense];
                        this.changeTo(conjugations[tense]);
                        return conjugations[tense];
                    }
                }, {
                    key: "to_present",
                    value: function to_present() {
                        var tense = "present";
                        var conjugations = this.conjugate(this.normal);
                        this.tag = verbTags[tense];
                        this.changeTo(conjugations[tense]);
                        return conjugations[tense];
                    }
                }, {
                    key: "to_future",
                    value: function to_future() {
                        var tense = "future";
                        var conjugations = this.conjugate(this.normal);
                        this.tag = verbTags[tense];
                        this.changeTo(conjugations[tense]);
                        return conjugations[tense];
                    }
                }, {
                    key: "to_adjective",
                    value: function to_adjective() {
                        return _to_adjective(this.conjugate().infinitive);
                    }
                }, {
                    key: "isNegative",
                    value: function isNegative() {
                        var str = this.normal;
                        if (str.match(/(n't|\bnot\b)/)) {
                            return true;
                        }
                        return false;
                    }
                }, {
                    key: "negate",
                    value: function negate() {
                        this.changeTo(_negate(this));
                        return this;
                    }
                } ]);
                return Verb;
            }(Term);
            Verb.fn = Verb.prototype;
            module.exports = Verb;
        }, {
            "../term.js": 97,
            "./conjugate/conjugate.js": 98,
            "./conjugate/predict_form.js": 101,
            "./to_adjective.js": 106,
            "./verb_negate.js": 108
        } ],
        108: [ function(require, module, exports) {
            "use strict";
            var fns = require("../../fns");
            var negate = function negate(v) {
                var known_negation = {
                    is: "isn't",
                    are: "aren't",
                    was: "wasn't",
                    will: "won't",
                    had: "hadn't",
                    did: "didn't",
                    would: "wouldn't",
                    could: "couldn't",
                    should: "shouldn't",
                    can: "can't",
                    must: "mustn't",
                    have: "haven't",
                    has: "hasn't",
                    does: "doesn't",
                    "do": "don't"
                };
                if (known_negation[v.normal]) {
                    return known_negation[v.normal];
                }
                var known_affirmation = fns.reverseObj(known_negation);
                if (known_affirmation[v.normal]) {
                    return known_affirmation[v.normal];
                }
                var words = v.normal.split(" ");
                if (words.length > 1 && words[1] === "not") {
                    return words[0];
                }
                if (words.length > 1 && known_negation[words[0]]) {
                    return known_negation[words[0]] + " " + words.slice(1, words.length).join(" ");
                }
                var form = v.conjugation();
                if (form === "PastTense") {
                    return "didn't " + v.conjugate()["infinitive"];
                }
                if (form === "PresentTense") {
                    return "doesn't " + v.conjugate()["infinitive"];
                }
                if (form === "Gerund") {
                    return "not " + v.text;
                }
                if (form === "Actor") {
                    return "non-" + v.text;
                }
                if (form === "Infinitive") {
                    return "don't " + v.text;
                }
                return v.text;
            };
            module.exports = negate;
        }, {
            "../../fns": 23
        } ],
        109: [ function(require, module, exports) {
            "use strict";
            var abbreviations = require("../data/abbreviations").abbreviations;
            var fns = require("../fns");
            var naiive_split = function naiive_split(text) {
                var splits = text.split(/(\n+)/);
                splits = splits.map(function(str) {
                    return str.split(/(\S.+?[.!?])(?=\s+|$)/g);
                });
                return fns.flatten(splits);
            };
            var sentence_parser = function sentence_parser(text) {
                var sentences = [];
                var chunks = [];
                if (!text || typeof text !== "string" || !text.match(/\w/)) {
                    return sentences;
                }
                var splits = naiive_split(text);
                for (var i = 0; i < splits.length; i++) {
                    var s = splits[i];
                    if (!s || s === "") {
                        continue;
                    }
                    if (!s.match(/\S/)) {
                        if (chunks[chunks.length - 1]) {
                            chunks[chunks.length - 1] += s;
                            continue;
                        } else if (splits[i + 1]) {
                            splits[i + 1] = s + splits[i + 1];
                            continue;
                        }
                    }
                    chunks.push(s);
                }
                var abbrev_reg = new RegExp("\\b(" + abbreviations.join("|") + ")[.!?] ?$", "i");
                var acronym_reg = new RegExp("[ |.][A-Z].? +?$", "i");
                var elipses_reg = new RegExp("\\.\\.\\.* +?$");
                for (var i = 0; i < chunks.length; i++) {
                    if (chunks[i + 1] && (chunks[i].match(abbrev_reg) || chunks[i].match(acronym_reg) || chunks[i].match(elipses_reg))) {
                        chunks[i + 1] = chunks[i] + (chunks[i + 1] || "");
                    } else if (chunks[i] && chunks[i].length > 0) {
                        sentences.push(chunks[i]);
                        chunks[i] = "";
                    }
                }
                if (sentences.length === 0) {
                    return [ text ];
                }
                return sentences;
            };
            module.exports = sentence_parser;
        }, {
            "../data/abbreviations": 1,
            "../fns": 23
        } ],
        110: [ function(require, module, exports) {
            "use strict";
            var _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                };
            }();
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            }
            var sentence_parser = require("./sentence_parser.js");
            var Question = require("../sentence/question/question.js");
            var Statement = require("../sentence/statement/statement.js");
            var fns = require("../fns.js");
            var Text = function() {
                function Text(str, options) {
                    _classCallCheck(this, Text);
                    options = options || {};
                    var the = this;
                    if (typeof str === "string") {
                        this.raw_text = str;
                    } else if (typeof str === "number") {
                        this.raw_text = "" + str;
                    } else {
                        this.raw_text = "";
                    }
                    this.sentences = sentence_parser(this.raw_text).map(function(s) {
                        var last_char = s.slice(-1);
                        if (last_char === "?") {
                            return new Question(s, options);
                        }
                        return new Statement(s, options);
                    });
                    this.contractions = {
                        expand: function expand() {
                            the.sentences = the.sentences.map(function(s) {
                                return s.contractions.expand();
                            });
                            return the;
                        },
                        contract: function contract() {
                            the.sentences = the.sentences.map(function(s) {
                                return s.contractions.contract();
                            });
                            return the;
                        }
                    };
                }
                _createClass(Text, [ {
                    key: "text",
                    value: function text() {
                        var arr = this.sentences.map(function(s) {
                            return s.text();
                        });
                        return fns.flatten(arr).join("");
                    }
                }, {
                    key: "normal",
                    value: function normal() {
                        var arr = this.sentences.map(function(s) {
                            return s.normal();
                        });
                        return fns.flatten(arr).join(" ");
                    }
                }, {
                    key: "root",
                    value: function root() {
                        var arr = this.sentences.map(function(s) {
                            return s.root();
                        });
                        return fns.flatten(arr).join(" ");
                    }
                }, {
                    key: "terms",
                    value: function terms() {
                        var arr = this.sentences.map(function(s) {
                            return s.terms;
                        });
                        return fns.flatten(arr);
                    }
                }, {
                    key: "tags",
                    value: function tags() {
                        return this.sentences.map(function(s) {
                            return s.tags();
                        });
                    }
                }, {
                    key: "match",
                    value: function match(str, options) {
                        var arr = [];
                        for (var i = 0; i < this.sentences.length; i++) {
                            arr = arr.concat(this.sentences[i].match(str, options));
                        }
                        return arr;
                    }
                }, {
                    key: "replace",
                    value: function replace(str, replacement, options) {
                        for (var i = 0; i < this.sentences.length; i++) {
                            this.sentences[i].replace(str, replacement, options);
                        }
                        return this;
                    }
                }, {
                    key: "to_past",
                    value: function to_past() {
                        this.sentences = this.sentences.map(function(s) {
                            return s.to_past();
                        });
                        return this;
                    }
                }, {
                    key: "to_present",
                    value: function to_present() {
                        this.sentences = this.sentences.map(function(s) {
                            return s.to_present();
                        });
                        return this;
                    }
                }, {
                    key: "to_future",
                    value: function to_future() {
                        this.sentences = this.sentences.map(function(s) {
                            return s.to_future();
                        });
                        return this;
                    }
                }, {
                    key: "negate",
                    value: function negate() {
                        this.sentences = this.sentences.map(function(s) {
                            return s.negate();
                        });
                        return this;
                    }
                }, {
                    key: "nouns",
                    value: function nouns() {
                        var arr = [];
                        for (var i = 0; i < this.sentences.length; i++) {
                            arr = arr.concat(this.sentences[i].nouns());
                        }
                        return arr;
                    }
                }, {
                    key: "adjectives",
                    value: function adjectives() {
                        var arr = [];
                        for (var i = 0; i < this.sentences.length; i++) {
                            arr = arr.concat(this.sentences[i].adjectives());
                        }
                        return arr;
                    }
                }, {
                    key: "verbs",
                    value: function verbs() {
                        var arr = [];
                        for (var i = 0; i < this.sentences.length; i++) {
                            arr = arr.concat(this.sentences[i].verbs());
                        }
                        return arr;
                    }
                }, {
                    key: "adverbs",
                    value: function adverbs() {
                        var arr = [];
                        for (var i = 0; i < this.sentences.length; i++) {
                            arr = arr.concat(this.sentences[i].adverbs());
                        }
                        return arr;
                    }
                }, {
                    key: "people",
                    value: function people() {
                        var arr = [];
                        for (var i = 0; i < this.sentences.length; i++) {
                            arr = arr.concat(this.sentences[i].people());
                        }
                        return arr;
                    }
                }, {
                    key: "places",
                    value: function places() {
                        var arr = [];
                        for (var i = 0; i < this.sentences.length; i++) {
                            arr = arr.concat(this.sentences[i].places());
                        }
                        return arr;
                    }
                }, {
                    key: "organizations",
                    value: function organizations() {
                        var arr = [];
                        for (var i = 0; i < this.sentences.length; i++) {
                            arr = arr.concat(this.sentences[i].organizations());
                        }
                        return arr;
                    }
                }, {
                    key: "dates",
                    value: function dates() {
                        var arr = [];
                        for (var i = 0; i < this.sentences.length; i++) {
                            arr = arr.concat(this.sentences[i].dates());
                        }
                        return arr;
                    }
                }, {
                    key: "values",
                    value: function values() {
                        var arr = [];
                        for (var i = 0; i < this.sentences.length; i++) {
                            arr = arr.concat(this.sentences[i].values());
                        }
                        return arr;
                    }
                }, {
                    key: "topics",
                    value: function topics() {
                        var obj = {};
                        for (var i = 0; i < this.sentences.length; i++) {
                            var topics = this.sentences[i].topics();
                            for (var o = 0; o < topics.length; o++) {
                                if (obj[topics[o].text]) {
                                    obj[topics[o].text].count += topics[o].count;
                                } else {
                                    obj[topics[o].text] = topics[o];
                                }
                            }
                        }
                        var arr = Object.keys(obj).map(function(k) {
                            return obj[k];
                        });
                        return arr.sort(function(a, b) {
                            if (a.count > b.count) {
                                return -1;
                            } else {
                                return 1;
                            }
                        });
                    }
                }, {
                    key: "word_count",
                    value: function word_count() {
                        var count = 0;
                        for (var i = 0; i < this.sentences.length; i++) {
                            count += this.sentences[i].word_count();
                        }
                        return count;
                    }
                } ]);
                return Text;
            }();
            Text.fn = Text.prototype;
            module.exports = Text;
        }, {
            "../fns.js": 23,
            "../sentence/question/question.js": 55,
            "../sentence/statement/statement.js": 61,
            "./sentence_parser.js": 109
        } ]
    }, {}, [ 24 ])(24);
});